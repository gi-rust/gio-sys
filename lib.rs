// This file was generated by grust-gen 0.2.1

#![crate_name = "gio_2_0_sys"]
#![crate_type = "lib"]

extern crate gtypes;
extern crate glib_2_0_sys as glib;
extern crate gobject_2_0_sys as gobject;
extern crate libc;

use gtypes::*;

#[repr(C)]
pub enum GSocketFamily {
    Invalid = 0,
    Unix = glib::GLIB_SYSDEF_AF_UNIX as isize,
    IPv4 = glib::GLIB_SYSDEF_AF_INET as isize,
    IPv6 = glib::GLIB_SYSDEF_AF_INET6 as isize,
}
pub const G_SOCKET_FAMILY_INVALID: GSocketFamily = GSocketFamily::Invalid;
pub const G_SOCKET_FAMILY_UNIX:    GSocketFamily = GSocketFamily::Unix;
pub const G_SOCKET_FAMILY_IPV4:    GSocketFamily = GSocketFamily::IPv4;
pub const G_SOCKET_FAMILY_IPV6:    GSocketFamily = GSocketFamily::IPv6;

#[repr(C)]
pub enum GSocketMsgFlags {
    None      = 0,
    Oob       = glib::GLIB_SYSDEF_MSG_OOB as isize,
    Peek      = glib::GLIB_SYSDEF_MSG_PEEK as isize,
    DontRoute = glib::GLIB_SYSDEF_MSG_DONTROUTE as isize,
}
pub const G_SOCKET_MSG_NONE:      guint = 0;
pub const G_SOCKET_MSG_OOB:       guint = glib::GLIB_SYSDEF_MSG_OOB as guint;
pub const G_SOCKET_MSG_PEEK:      guint = glib::GLIB_SYSDEF_MSG_PEEK as guint;
pub const G_SOCKET_MSG_DONTROUTE: guint = glib::GLIB_SYSDEF_MSG_DONTROUTE as guint;

pub enum GAction { }

#[repr(C)]
pub struct GActionEntry {
    pub name: *const gchar,
    pub activate: Option<extern "C" fn (*mut GSimpleAction, *mut glib::GVariant, gpointer)>,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: Option<extern "C" fn (*mut GSimpleAction, *mut glib::GVariant, gpointer)>,
    padding: [gsize; 3],
}

pub enum GActionGroup { }

#[repr(C)]
pub struct GActionGroupInterface {
    pub g_iface: gobject::GTypeInterface,
    pub has_action: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> gboolean>,
    pub list_actions: Option<extern "C" fn (*mut GActionGroup) -> *mut *mut gchar>,
    pub get_action_enabled: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> gboolean>,
    pub get_action_parameter_type: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> *const glib::GVariantType>,
    pub get_action_state_type: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> *const glib::GVariantType>,
    pub get_action_state_hint: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> *mut glib::GVariant>,
    pub get_action_state: Option<extern "C" fn (*mut GActionGroup, *const gchar) -> *mut glib::GVariant>,
    pub change_action_state: Option<extern "C" fn (*mut GActionGroup, *const gchar, *mut glib::GVariant)>,
    pub activate_action: Option<extern "C" fn (*mut GActionGroup, *const gchar, *mut glib::GVariant)>,
    pub action_added: Option<extern "C" fn (*mut GActionGroup, *const gchar)>,
    pub action_removed: Option<extern "C" fn (*mut GActionGroup, *const gchar)>,
    pub action_enabled_changed: Option<extern "C" fn (*mut GActionGroup, *const gchar, gboolean)>,
    pub action_state_changed: Option<extern "C" fn (*mut GActionGroup, *const gchar, *mut glib::GVariant)>,
    pub query_action: Option<extern "C" fn (*mut GActionGroup, *const gchar, *mut gboolean, *mut *const glib::GVariantType, *mut *const glib::GVariantType, *mut *mut glib::GVariant, *mut *mut glib::GVariant) -> gboolean>,
}

#[repr(C)]
pub struct GActionInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_name: Option<extern "C" fn (*mut GAction) -> *const gchar>,
    pub get_parameter_type: Option<extern "C" fn (*mut GAction) -> *const glib::GVariantType>,
    pub get_state_type: Option<extern "C" fn (*mut GAction) -> *const glib::GVariantType>,
    pub get_state_hint: Option<extern "C" fn (*mut GAction) -> *mut glib::GVariant>,
    pub get_enabled: Option<extern "C" fn (*mut GAction) -> gboolean>,
    pub get_state: Option<extern "C" fn (*mut GAction) -> *mut glib::GVariant>,
    pub change_state: Option<extern "C" fn (*mut GAction, *mut glib::GVariant)>,
    pub activate: Option<extern "C" fn (*mut GAction, *mut glib::GVariant)>,
}

pub enum GActionMap { }

#[repr(C)]
pub struct GActionMapInterface {
    pub g_iface: gobject::GTypeInterface,
    pub lookup_action: Option<extern "C" fn (*mut GActionMap, *const gchar) -> *mut GAction>,
    pub add_action: Option<extern "C" fn (*mut GActionMap, *mut GAction)>,
    pub remove_action: Option<extern "C" fn (*mut GActionMap, *const gchar)>,
}

pub enum GAppInfo { }

#[repr(C)]
pub enum GAppInfoCreateFlags {
    None = 0,
    NeedsTerminal = 1,
    SupportsUris = 2,
    SupportsStartupNotification = 4,
}
pub const G_APP_INFO_CREATE_NONE: guint = 0;
pub const G_APP_INFO_CREATE_NEEDS_TERMINAL: guint = 1;
pub const G_APP_INFO_CREATE_SUPPORTS_URIS: guint = 2;
pub const G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: guint = 4;

#[repr(C)]
pub struct GAppInfoIface {
    pub g_iface: gobject::GTypeInterface,
    pub dup: Option<extern "C" fn (*mut GAppInfo) -> *mut GAppInfo>,
    pub equal: Option<extern "C" fn (*mut GAppInfo, *mut GAppInfo) -> gboolean>,
    pub get_id: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub get_name: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub get_description: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub get_executable: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub get_icon: Option<extern "C" fn (*mut GAppInfo) -> *mut GIcon>,
    pub launch: Option<extern "C" fn (*mut GAppInfo, *mut glib::GList, *mut GAppLaunchContext) -> gboolean>,
    pub supports_uris: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub supports_files: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub launch_uris: Option<extern "C" fn (*mut GAppInfo, *mut glib::GList, *mut GAppLaunchContext) -> gboolean>,
    pub should_show: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: Option<extern "C" fn (*mut GAppInfo, *const gchar) -> gboolean>,
    pub set_as_default_for_extension: Option<extern "C" fn (*mut GAppInfo, *const gchar) -> gboolean>,
    pub add_supports_type: Option<extern "C" fn (*mut GAppInfo, *const gchar) -> gboolean>,
    pub can_remove_supports_type: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub remove_supports_type: Option<extern "C" fn (*mut GAppInfo, *const gchar) -> gboolean>,
    pub can_delete: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub do_delete: Option<extern "C" fn (*mut GAppInfo) -> gboolean>,
    pub get_commandline: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub get_display_name: Option<extern "C" fn (*mut GAppInfo) -> *const gchar>,
    pub set_as_last_used_for_type: Option<extern "C" fn (*mut GAppInfo, *const gchar) -> gboolean>,
    pub get_supported_types: Option<extern "C" fn (*mut GAppInfo) -> *mut *mut gchar>,
}

pub enum GAppInfoMonitor { }

#[repr(C)]
pub struct GAppLaunchContext {
    pub parent_instance: gobject::GObject,
    priv_: *mut GAppLaunchContextPrivate,
}

#[repr(C)]
pub struct GAppLaunchContextClass {
    pub parent_class: gobject::GObjectClass,
    pub get_display: Option<extern "C" fn (*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GList) -> *mut gchar>,
    pub get_startup_notify_id: Option<extern "C" fn (*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GList) -> *mut gchar>,
    pub launch_failed: Option<extern "C" fn (*mut GAppLaunchContext, *const gchar)>,
    pub launched: Option<extern "C" fn (*mut GAppLaunchContext, *mut GAppInfo, *mut glib::GVariant)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GAppLaunchContextPrivate(gpointer);

#[repr(C)]
pub struct GApplication {
    parent_instance: gobject::GObject,
    priv_: *mut GApplicationPrivate,
}

#[repr(C)]
pub struct GApplicationClass {
    parent_class: gobject::GObjectClass,
    pub startup: Option<extern "C" fn (*mut GApplication)>,
    pub activate: Option<extern "C" fn (*mut GApplication)>,
    pub open: Option<extern "C" fn (*mut GApplication, *mut *mut GFile, gint, *const gchar)>,
    pub command_line: Option<extern "C" fn (*mut GApplication, *mut GApplicationCommandLine) -> gint>,
    pub local_command_line: Option<extern "C" fn (*mut GApplication, *mut *mut *mut gchar, *mut gint) -> gboolean>,
    pub before_emit: Option<extern "C" fn (*mut GApplication, *mut glib::GVariant)>,
    pub after_emit: Option<extern "C" fn (*mut GApplication, *mut glib::GVariant)>,
    pub add_platform_data: Option<extern "C" fn (*mut GApplication, *mut glib::GVariantBuilder)>,
    pub quit_mainloop: Option<extern "C" fn (*mut GApplication)>,
    pub run_mainloop: Option<extern "C" fn (*mut GApplication)>,
    pub shutdown: Option<extern "C" fn (*mut GApplication)>,
    pub dbus_register: Option<extern "C" fn (*mut GApplication, *mut GDBusConnection, *const gchar) -> gboolean>,
    pub dbus_unregister: Option<extern "C" fn (*mut GApplication, *mut GDBusConnection, *const gchar)>,
    pub handle_local_options: Option<extern "C" fn (*mut GApplication, *mut glib::GVariantDict) -> gint>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GApplicationCommandLine {
    parent_instance: gobject::GObject,
    priv_: *mut GApplicationCommandLinePrivate,
}

#[repr(C)]
pub struct GApplicationCommandLineClass {
    parent_class: gobject::GObjectClass,
    pub print_literal: Option<extern "C" fn (*mut GApplicationCommandLine, *const gchar)>,
    pub printerr_literal: Option<extern "C" fn (*mut GApplicationCommandLine, *const gchar)>,
    pub get_stdin: Option<extern "C" fn (*mut GApplicationCommandLine) -> *mut GInputStream>,
    padding: [gpointer; 11],
}

#[repr(C)]
pub struct GApplicationCommandLinePrivate(gpointer);

#[repr(C)]
pub enum GApplicationFlags {
    FlagsNone = 0,
    IsService = 1,
    IsLauncher = 2,
    HandlesOpen = 4,
    HandlesCommandLine = 8,
    SendEnvironment = 16,
    NonUnique = 32,
}
pub const G_APPLICATION_FLAGS_NONE: guint = 0;
pub const G_APPLICATION_IS_SERVICE: guint = 1;
pub const G_APPLICATION_IS_LAUNCHER: guint = 2;
pub const G_APPLICATION_HANDLES_OPEN: guint = 4;
pub const G_APPLICATION_HANDLES_COMMAND_LINE: guint = 8;
pub const G_APPLICATION_SEND_ENVIRONMENT: guint = 16;
pub const G_APPLICATION_NON_UNIQUE: guint = 32;

#[repr(C)]
pub struct GApplicationPrivate(gpointer);

#[repr(C)]
pub enum GAskPasswordFlags {
    NeedPassword = 1,
    NeedUsername = 2,
    NeedDomain = 4,
    SavingSupported = 8,
    AnonymousSupported = 16,
}
pub const G_ASK_PASSWORD_NEED_PASSWORD: guint = 1;
pub const G_ASK_PASSWORD_NEED_USERNAME: guint = 2;
pub const G_ASK_PASSWORD_NEED_DOMAIN: guint = 4;
pub const G_ASK_PASSWORD_SAVING_SUPPORTED: guint = 8;
pub const G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: guint = 16;

pub enum GAsyncInitable { }

#[repr(C)]
pub struct GAsyncInitableIface {
    pub g_iface: gobject::GTypeInterface,
    pub init_async: Option<extern "C" fn (*mut GAsyncInitable, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub init_finish: Option<extern "C" fn (*mut GAsyncInitable, *mut GAsyncResult) -> gboolean>,
}

pub type GAsyncReadyCallback = extern "C" fn (*mut gobject::GObject, *mut GAsyncResult, gpointer);

pub enum GAsyncResult { }

#[repr(C)]
pub struct GAsyncResultIface {
    pub g_iface: gobject::GTypeInterface,
    pub get_user_data: Option<extern "C" fn (*mut GAsyncResult) -> gpointer>,
    pub get_source_object: Option<extern "C" fn (*mut GAsyncResult) -> *mut gobject::GObject>,
    pub is_tagged: Option<extern "C" fn (*mut GAsyncResult, gpointer) -> gboolean>,
}

#[repr(C)]
pub struct GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    priv_: *mut GBufferedInputStreamPrivate,
}

#[repr(C)]
pub struct GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: Option<extern "C" fn (*mut GBufferedInputStream, gssize, *mut GCancellable) -> gssize>,
    pub fill_async: Option<extern "C" fn (*mut GBufferedInputStream, gssize, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub fill_finish: Option<extern "C" fn (*mut GBufferedInputStream, *mut GAsyncResult) -> gssize>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GBufferedInputStreamPrivate(gpointer);

#[repr(C)]
pub struct GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}

#[repr(C)]
pub struct GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GBufferedOutputStreamPrivate(gpointer);

pub type GBusAcquiredCallback = extern "C" fn (*mut GDBusConnection, *const gchar, gpointer);

pub type GBusNameAcquiredCallback = extern "C" fn (*mut GDBusConnection, *const gchar, gpointer);

pub type GBusNameAppearedCallback = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, gpointer);

pub type GBusNameLostCallback = extern "C" fn (*mut GDBusConnection, *const gchar, gpointer);

#[repr(C)]
pub enum GBusNameOwnerFlags {
    None = 0,
    AllowReplacement = 1,
    Replace = 2,
}
pub const G_BUS_NAME_OWNER_FLAGS_NONE: guint = 0;
pub const G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: guint = 1;
pub const G_BUS_NAME_OWNER_FLAGS_REPLACE: guint = 2;

pub type GBusNameVanishedCallback = extern "C" fn (*mut GDBusConnection, *const gchar, gpointer);

#[repr(C)]
pub enum GBusNameWatcherFlags {
    None = 0,
    AutoStart = 1,
}
pub const G_BUS_NAME_WATCHER_FLAGS_NONE: guint = 0;
pub const G_BUS_NAME_WATCHER_FLAGS_AUTO_START: guint = 1;

#[repr(C)]
pub enum GBusType {
    Starter = -1,
    None = 0,
    System = 1,
    Session = 2,
}
pub const G_BUS_TYPE_STARTER: GBusType = GBusType::Starter;
pub const G_BUS_TYPE_NONE: GBusType = GBusType::None;
pub const G_BUS_TYPE_SYSTEM: GBusType = GBusType::System;
pub const G_BUS_TYPE_SESSION: GBusType = GBusType::Session;

pub enum GBytesIcon { }

#[repr(C)]
pub struct GCancellable {
    pub parent_instance: gobject::GObject,
    priv_: *mut GCancellablePrivate,
}

#[repr(C)]
pub struct GCancellableClass {
    pub parent_class: gobject::GObjectClass,
    pub cancelled: Option<extern "C" fn (*mut GCancellable)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GCancellablePrivate(gpointer);

pub type GCancellableSourceFunc = extern "C" fn (*mut GCancellable, gpointer) -> gboolean;

pub enum GCharsetConverter { }

#[repr(C)]
pub struct GCharsetConverterClass {
    pub parent_class: gobject::GObjectClass,
}

pub enum GConverter { }

#[repr(C)]
pub enum GConverterFlags {
    None = 0,
    InputAtEnd = 1,
    Flush = 2,
}
pub const G_CONVERTER_NO_FLAGS: guint = 0;
pub const G_CONVERTER_INPUT_AT_END: guint = 1;
pub const G_CONVERTER_FLUSH: guint = 2;

#[repr(C)]
pub struct GConverterIface {
    pub g_iface: gobject::GTypeInterface,
    pub convert: Option<extern "C" fn (*mut GConverter, *mut u8, gsize, *mut u8, gsize, GConverterFlags, *mut gsize, *mut gsize) -> GConverterResult>,
    pub reset: Option<extern "C" fn (*mut GConverter)>,
}

#[repr(C)]
pub struct GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    priv_: *mut GConverterInputStreamPrivate,
}

#[repr(C)]
pub struct GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GConverterInputStreamPrivate(gpointer);

#[repr(C)]
pub struct GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    priv_: *mut GConverterOutputStreamPrivate,
}

#[repr(C)]
pub struct GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GConverterOutputStreamPrivate(gpointer);

#[repr(C)]
pub enum GConverterResult {
    Error = 0,
    Converted = 1,
    Finished = 2,
    Flushed = 3,
}
pub const G_CONVERTER_ERROR: GConverterResult = GConverterResult::Error;
pub const G_CONVERTER_CONVERTED: GConverterResult = GConverterResult::Converted;
pub const G_CONVERTER_FINISHED: GConverterResult = GConverterResult::Finished;
pub const G_CONVERTER_FLUSHED: GConverterResult = GConverterResult::Flushed;

pub enum GCredentials { }

#[repr(C)]
pub struct GCredentialsClass(gpointer);

#[repr(C)]
pub enum GCredentialsType {
    Invalid = 0,
    LinuxUcred = 1,
    FreebsdCmsgcred = 2,
    OpenbsdSockpeercred = 3,
    SolarisUcred = 4,
    NetbsdUnpcbid = 5,
}
pub const G_CREDENTIALS_TYPE_INVALID: GCredentialsType = GCredentialsType::Invalid;
pub const G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = GCredentialsType::LinuxUcred;
pub const G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = GCredentialsType::FreebsdCmsgcred;
pub const G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = GCredentialsType::OpenbsdSockpeercred;
pub const G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = GCredentialsType::SolarisUcred;
pub const G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = GCredentialsType::NetbsdUnpcbid;

pub enum GDBusActionGroup { }

#[repr(C)]
pub struct GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub struct GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

pub enum GDBusAuthObserver { }

#[repr(C)]
pub enum GDBusCallFlags {
    None = 0,
    NoAutoStart = 1,
    AllowInteractiveAuthorization = 2,
}
pub const G_DBUS_CALL_FLAGS_NONE: guint = 0;
pub const G_DBUS_CALL_FLAGS_NO_AUTO_START: guint = 1;
pub const G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: guint = 2;

#[repr(C)]
pub enum GDBusCapabilityFlags {
    None = 0,
    UnixFdPassing = 1,
}
pub const G_DBUS_CAPABILITY_FLAGS_NONE: guint = 0;
pub const G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: guint = 1;

pub enum GDBusConnection { }

#[repr(C)]
pub enum GDBusConnectionFlags {
    None = 0,
    AuthenticationClient = 1,
    AuthenticationServer = 2,
    AuthenticationAllowAnonymous = 4,
    MessageBusConnection = 8,
    DelayMessageProcessing = 16,
}
pub const G_DBUS_CONNECTION_FLAGS_NONE: guint = 0;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: guint = 1;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: guint = 2;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: guint = 4;
pub const G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: guint = 8;
pub const G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: guint = 16;

#[repr(C)]
pub enum GDBusError {
    Failed = 0,
    NoMemory = 1,
    ServiceUnknown = 2,
    NameHasNoOwner = 3,
    NoReply = 4,
    IoError = 5,
    BadAddress = 6,
    NotSupported = 7,
    LimitsExceeded = 8,
    AccessDenied = 9,
    AuthFailed = 10,
    NoServer = 11,
    Timeout = 12,
    NoNetwork = 13,
    AddressInUse = 14,
    Disconnected = 15,
    InvalidArgs = 16,
    FileNotFound = 17,
    FileExists = 18,
    UnknownMethod = 19,
    TimedOut = 20,
    MatchRuleNotFound = 21,
    MatchRuleInvalid = 22,
    SpawnExecFailed = 23,
    SpawnForkFailed = 24,
    SpawnChildExited = 25,
    SpawnChildSignaled = 26,
    SpawnFailed = 27,
    SpawnSetupFailed = 28,
    SpawnConfigInvalid = 29,
    SpawnServiceInvalid = 30,
    SpawnServiceNotFound = 31,
    SpawnPermissionsInvalid = 32,
    SpawnFileInvalid = 33,
    SpawnNoMemory = 34,
    UnixProcessIdUnknown = 35,
    InvalidSignature = 36,
    InvalidFileContent = 37,
    SelinuxSecurityContextUnknown = 38,
    AdtAuditDataUnknown = 39,
    ObjectPathInUse = 40,
    UnknownObject = 41,
    UnknownInterface = 42,
    UnknownProperty = 43,
    PropertyReadOnly = 44,
}
pub const G_DBUS_ERROR_FAILED: GDBusError = GDBusError::Failed;
pub const G_DBUS_ERROR_NO_MEMORY: GDBusError = GDBusError::NoMemory;
pub const G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = GDBusError::ServiceUnknown;
pub const G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = GDBusError::NameHasNoOwner;
pub const G_DBUS_ERROR_NO_REPLY: GDBusError = GDBusError::NoReply;
pub const G_DBUS_ERROR_IO_ERROR: GDBusError = GDBusError::IoError;
pub const G_DBUS_ERROR_BAD_ADDRESS: GDBusError = GDBusError::BadAddress;
pub const G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = GDBusError::NotSupported;
pub const G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = GDBusError::LimitsExceeded;
pub const G_DBUS_ERROR_ACCESS_DENIED: GDBusError = GDBusError::AccessDenied;
pub const G_DBUS_ERROR_AUTH_FAILED: GDBusError = GDBusError::AuthFailed;
pub const G_DBUS_ERROR_NO_SERVER: GDBusError = GDBusError::NoServer;
pub const G_DBUS_ERROR_TIMEOUT: GDBusError = GDBusError::Timeout;
pub const G_DBUS_ERROR_NO_NETWORK: GDBusError = GDBusError::NoNetwork;
pub const G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = GDBusError::AddressInUse;
pub const G_DBUS_ERROR_DISCONNECTED: GDBusError = GDBusError::Disconnected;
pub const G_DBUS_ERROR_INVALID_ARGS: GDBusError = GDBusError::InvalidArgs;
pub const G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = GDBusError::FileNotFound;
pub const G_DBUS_ERROR_FILE_EXISTS: GDBusError = GDBusError::FileExists;
pub const G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = GDBusError::UnknownMethod;
pub const G_DBUS_ERROR_TIMED_OUT: GDBusError = GDBusError::TimedOut;
pub const G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = GDBusError::MatchRuleNotFound;
pub const G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = GDBusError::MatchRuleInvalid;
pub const G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = GDBusError::SpawnExecFailed;
pub const G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = GDBusError::SpawnForkFailed;
pub const G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = GDBusError::SpawnChildExited;
pub const G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = GDBusError::SpawnChildSignaled;
pub const G_DBUS_ERROR_SPAWN_FAILED: GDBusError = GDBusError::SpawnFailed;
pub const G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = GDBusError::SpawnSetupFailed;
pub const G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = GDBusError::SpawnConfigInvalid;
pub const G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = GDBusError::SpawnServiceInvalid;
pub const G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = GDBusError::SpawnServiceNotFound;
pub const G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = GDBusError::SpawnPermissionsInvalid;
pub const G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = GDBusError::SpawnFileInvalid;
pub const G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = GDBusError::SpawnNoMemory;
pub const G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = GDBusError::UnixProcessIdUnknown;
pub const G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = GDBusError::InvalidSignature;
pub const G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = GDBusError::InvalidFileContent;
pub const G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = GDBusError::SelinuxSecurityContextUnknown;
pub const G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = GDBusError::AdtAuditDataUnknown;
pub const G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = GDBusError::ObjectPathInUse;
pub const G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = GDBusError::UnknownObject;
pub const G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = GDBusError::UnknownInterface;
pub const G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = GDBusError::UnknownProperty;
pub const G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = GDBusError::PropertyReadOnly;

#[repr(C)]
pub struct GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}

pub enum GDBusInterface { }

pub type GDBusInterfaceGetPropertyFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, *const gchar, *mut *mut glib::GError, gpointer) -> *mut glib::GVariant;

#[repr(C)]
pub struct GDBusInterfaceIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_info: Option<extern "C" fn (*mut GDBusInterface) -> *mut GDBusInterfaceInfo>,
    pub get_object: Option<extern "C" fn (*mut GDBusInterface) -> *mut GDBusObject>,
    pub set_object: Option<extern "C" fn (*mut GDBusInterface, *mut GDBusObject)>,
    pub dup_object: Option<extern "C" fn (*mut GDBusInterface) -> *mut GDBusObject>,
}

#[repr(C)]
pub struct GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

pub type GDBusInterfaceMethodCallFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, *const gchar, *mut glib::GVariant, *mut GDBusMethodInvocation, gpointer);

pub type GDBusInterfaceSetPropertyFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, *const gchar, *mut glib::GVariant, *mut *mut glib::GError, gpointer) -> gboolean;

#[repr(C)]
pub struct GDBusInterfaceSkeleton {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusInterfaceSkeletonPrivate,
}

#[repr(C)]
pub struct GDBusInterfaceSkeletonClass {
    pub parent_class: gobject::GObjectClass,
    pub get_info: Option<extern "C" fn (*mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo>,
    pub get_vtable: Option<extern "C" fn (*mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable>,
    pub get_properties: Option<extern "C" fn (*mut GDBusInterfaceSkeleton) -> *mut glib::GVariant>,
    pub flush: Option<extern "C" fn (*mut GDBusInterfaceSkeleton)>,
    vfunc_padding: [gpointer; 8],
    pub g_authorize_method: Option<extern "C" fn (*mut GDBusInterfaceSkeleton, *mut GDBusMethodInvocation) -> gboolean>,
    signal_padding: [gpointer; 8],
}

#[repr(C)]
pub enum GDBusInterfaceSkeletonFlags {
    None = 0,
    HandleMethodInvocationsInThread = 1,
}
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: guint = 0;
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: guint = 1;

#[repr(C)]
pub struct GDBusInterfaceSkeletonPrivate(gpointer);

#[repr(C)]
pub struct GDBusInterfaceVTable {
    pub method_call: Option<GDBusInterfaceMethodCallFunc>,
    pub get_property: Option<GDBusInterfaceGetPropertyFunc>,
    pub set_property: Option<GDBusInterfaceSetPropertyFunc>,
    padding: [gpointer; 8],
}

pub enum GDBusMenuModel { }

pub enum GDBusMessage { }

#[repr(C)]
pub enum GDBusMessageByteOrder {
    BigEndian = 66,
    LittleEndian = 108,
}
pub const G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = GDBusMessageByteOrder::BigEndian;
pub const G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder = GDBusMessageByteOrder::LittleEndian;

pub type GDBusMessageFilterFunction = extern "C" fn (*mut GDBusConnection, *mut GDBusMessage, gboolean, gpointer) -> *mut GDBusMessage;

#[repr(C)]
pub enum GDBusMessageFlags {
    None = 0,
    NoReplyExpected = 1,
    NoAutoStart = 2,
    AllowInteractiveAuthorization = 4,
}
pub const G_DBUS_MESSAGE_FLAGS_NONE: guint = 0;
pub const G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: guint = 1;
pub const G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: guint = 2;
pub const G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: guint = 4;

#[repr(C)]
pub enum GDBusMessageHeaderField {
    Invalid = 0,
    Path = 1,
    Interface = 2,
    Member = 3,
    ErrorName = 4,
    ReplySerial = 5,
    Destination = 6,
    Sender = 7,
    Signature = 8,
    NumUnixFds = 9,
}
pub const G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = GDBusMessageHeaderField::Invalid;
pub const G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = GDBusMessageHeaderField::Path;
pub const G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField = GDBusMessageHeaderField::Interface;
pub const G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = GDBusMessageHeaderField::Member;
pub const G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField = GDBusMessageHeaderField::ErrorName;
pub const G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: GDBusMessageHeaderField = GDBusMessageHeaderField::ReplySerial;
pub const G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField = GDBusMessageHeaderField::Destination;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = GDBusMessageHeaderField::Sender;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField = GDBusMessageHeaderField::Signature;
pub const G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: GDBusMessageHeaderField = GDBusMessageHeaderField::NumUnixFds;

#[repr(C)]
pub enum GDBusMessageType {
    Invalid = 0,
    MethodCall = 1,
    MethodReturn = 2,
    Error = 3,
    Signal = 4,
}
pub const G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = GDBusMessageType::Invalid;
pub const G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = GDBusMessageType::MethodCall;
pub const G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = GDBusMessageType::MethodReturn;
pub const G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = GDBusMessageType::Error;
pub const G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = GDBusMessageType::Signal;

#[repr(C)]
pub struct GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

pub enum GDBusMethodInvocation { }

#[repr(C)]
pub struct GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

pub enum GDBusObject { }

#[repr(C)]
pub struct GDBusObjectIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_object_path: Option<extern "C" fn (*mut GDBusObject) -> *const gchar>,
    pub get_interfaces: Option<extern "C" fn (*mut GDBusObject) -> *mut glib::GList>,
    pub get_interface: Option<extern "C" fn (*mut GDBusObject, *const gchar) -> *mut GDBusInterface>,
    pub interface_added: Option<extern "C" fn (*mut GDBusObject, *mut GDBusInterface)>,
    pub interface_removed: Option<extern "C" fn (*mut GDBusObject, *mut GDBusInterface)>,
}

pub enum GDBusObjectManager { }

#[repr(C)]
pub struct GDBusObjectManagerClient {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectManagerClientPrivate,
}

#[repr(C)]
pub struct GDBusObjectManagerClientClass {
    pub parent_class: gobject::GObjectClass,
    pub interface_proxy_signal: Option<extern "C" fn (*mut GDBusObjectManagerClient, *mut GDBusObjectProxy, *mut GDBusProxy, *const gchar, *const gchar, *mut glib::GVariant)>,
    pub interface_proxy_properties_changed: Option<extern "C" fn (*mut GDBusObjectManagerClient, *mut GDBusObjectProxy, *mut GDBusProxy, *mut glib::GVariant, *const *const gchar)>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub enum GDBusObjectManagerClientFlags {
    None = 0,
    DoNotAutoStart = 1,
}
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: guint = 0;
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: guint = 1;

#[repr(C)]
pub struct GDBusObjectManagerClientPrivate(gpointer);

#[repr(C)]
pub struct GDBusObjectManagerIface {
    pub parent_iface: gobject::GTypeInterface,
    pub get_object_path: Option<extern "C" fn (*mut GDBusObjectManager) -> *const gchar>,
    pub get_objects: Option<extern "C" fn (*mut GDBusObjectManager) -> *mut glib::GList>,
    pub get_object: Option<extern "C" fn (*mut GDBusObjectManager, *const gchar) -> *mut GDBusObject>,
    pub get_interface: Option<extern "C" fn (*mut GDBusObjectManager, *const gchar, *const gchar) -> *mut GDBusInterface>,
    pub object_added: Option<extern "C" fn (*mut GDBusObjectManager, *mut GDBusObject)>,
    pub object_removed: Option<extern "C" fn (*mut GDBusObjectManager, *mut GDBusObject)>,
    pub interface_added: Option<extern "C" fn (*mut GDBusObjectManager, *mut GDBusObject, *mut GDBusInterface)>,
    pub interface_removed: Option<extern "C" fn (*mut GDBusObjectManager, *mut GDBusObject, *mut GDBusInterface)>,
}

#[repr(C)]
pub struct GDBusObjectManagerServer {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectManagerServerPrivate,
}

#[repr(C)]
pub struct GDBusObjectManagerServerClass {
    pub parent_class: gobject::GObjectClass,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectManagerServerPrivate(gpointer);

#[repr(C)]
pub struct GDBusObjectProxy {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectProxyPrivate,
}

#[repr(C)]
pub struct GDBusObjectProxyClass {
    pub parent_class: gobject::GObjectClass,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectProxyPrivate(gpointer);

#[repr(C)]
pub struct GDBusObjectSkeleton {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusObjectSkeletonPrivate,
}

#[repr(C)]
pub struct GDBusObjectSkeletonClass {
    pub parent_class: gobject::GObjectClass,
    pub authorize_method: Option<extern "C" fn (*mut GDBusObjectSkeleton, *mut GDBusInterfaceSkeleton, *mut GDBusMethodInvocation) -> gboolean>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GDBusObjectSkeletonPrivate(gpointer);

#[repr(C)]
pub struct GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

#[repr(C)]
pub enum GDBusPropertyInfoFlags {
    None = 0,
    Readable = 1,
    Writable = 2,
}
pub const G_DBUS_PROPERTY_INFO_FLAGS_NONE: guint = 0;
pub const G_DBUS_PROPERTY_INFO_FLAGS_READABLE: guint = 1;
pub const G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: guint = 2;

#[repr(C)]
pub struct GDBusProxy {
    parent_instance: gobject::GObject,
    priv_: *mut GDBusProxyPrivate,
}

#[repr(C)]
pub struct GDBusProxyClass {
    parent_class: gobject::GObjectClass,
    pub g_properties_changed: Option<extern "C" fn (*mut GDBusProxy, *mut glib::GVariant, *const *const gchar)>,
    pub g_signal: Option<extern "C" fn (*mut GDBusProxy, *const gchar, *const gchar, *mut glib::GVariant)>,
    padding: [gpointer; 32],
}

#[repr(C)]
pub enum GDBusProxyFlags {
    None = 0,
    DoNotLoadProperties = 1,
    DoNotConnectSignals = 2,
    DoNotAutoStart = 4,
    GetInvalidatedProperties = 8,
    DoNotAutoStartAtConstruction = 16,
}
pub const G_DBUS_PROXY_FLAGS_NONE: guint = 0;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: guint = 1;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: guint = 2;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: guint = 4;
pub const G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: guint = 8;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: guint = 16;

#[repr(C)]
pub struct GDBusProxyPrivate(gpointer);

pub type GDBusProxyTypeFunc = extern "C" fn (*mut GDBusObjectManagerClient, *const gchar, *const gchar, gpointer) -> GType;

#[repr(C)]
pub enum GDBusSendMessageFlags {
    None = 0,
    PreserveSerial = 1,
}
pub const G_DBUS_SEND_MESSAGE_FLAGS_NONE: guint = 0;
pub const G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: guint = 1;

pub enum GDBusServer { }

#[repr(C)]
pub enum GDBusServerFlags {
    None = 0,
    RunInThread = 1,
    AuthenticationAllowAnonymous = 2,
}
pub const G_DBUS_SERVER_FLAGS_NONE: guint = 0;
pub const G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: guint = 1;
pub const G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: guint = 2;

pub type GDBusSignalCallback = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, *const gchar, *mut glib::GVariant, gpointer);

#[repr(C)]
pub enum GDBusSignalFlags {
    None = 0,
    NoMatchRule = 1,
    MatchArg0Namespace = 2,
    MatchArg0Path = 4,
}
pub const G_DBUS_SIGNAL_FLAGS_NONE: guint = 0;
pub const G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: guint = 1;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: guint = 2;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: guint = 4;

#[repr(C)]
pub struct GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}

pub type GDBusSubtreeDispatchFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, *const gchar, gpointer, gpointer) -> *const GDBusInterfaceVTable;

pub type GDBusSubtreeEnumerateFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, gpointer) -> *mut *mut gchar;

#[repr(C)]
pub enum GDBusSubtreeFlags {
    None = 0,
    DispatchToUnenumeratedNodes = 1,
}
pub const G_DBUS_SUBTREE_FLAGS_NONE: guint = 0;
pub const G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: guint = 1;

pub type GDBusSubtreeIntrospectFunc = extern "C" fn (*mut GDBusConnection, *const gchar, *const gchar, *const gchar, gpointer) -> *mut *mut GDBusInterfaceInfo;

#[repr(C)]
pub struct GDBusSubtreeVTable {
    pub enumerate: Option<GDBusSubtreeEnumerateFunc>,
    pub introspect: Option<GDBusSubtreeIntrospectFunc>,
    pub dispatch: Option<GDBusSubtreeDispatchFunc>,
    padding: [gpointer; 8],
}

pub const G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: &'static [u8] = b"gio-desktop-app-info-lookup\0";

#[repr(C)]
pub struct GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    priv_: *mut GDataInputStreamPrivate,
}

#[repr(C)]
pub struct GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GDataInputStreamPrivate(gpointer);

#[repr(C)]
pub struct GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    priv_: *mut GDataOutputStreamPrivate,
}

#[repr(C)]
pub struct GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GDataOutputStreamPrivate(gpointer);

#[repr(C)]
pub enum GDataStreamByteOrder {
    BigEndian = 0,
    LittleEndian = 1,
    HostEndian = 2,
}
pub const G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::BigEndian;
pub const G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::LittleEndian;
pub const G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = GDataStreamByteOrder::HostEndian;

#[repr(C)]
pub enum GDataStreamNewlineType {
    Lf = 0,
    Cr = 1,
    CrLf = 2,
    Any = 3,
}
pub const G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = GDataStreamNewlineType::Lf;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = GDataStreamNewlineType::Cr;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = GDataStreamNewlineType::CrLf;
pub const G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = GDataStreamNewlineType::Any;

pub enum GDatagramBased { }

#[repr(C)]
pub struct GDatagramBasedInterface {
    pub g_iface: gobject::GTypeInterface,
    pub receive_messages: Option<extern "C" fn (*mut GDatagramBased, *mut GInputMessage, guint, gint, i64, *mut GCancellable) -> gint>,
    pub send_messages: Option<extern "C" fn (*mut GDatagramBased, *mut GOutputMessage, guint, gint, i64, *mut GCancellable) -> gint>,
    pub create_source: Option<extern "C" fn (*mut GDatagramBased, glib::GIOCondition, *mut GCancellable) -> *mut glib::GSource>,
    pub condition_check: Option<extern "C" fn (*mut GDatagramBased, glib::GIOCondition) -> glib::GIOCondition>,
    pub condition_wait: Option<extern "C" fn (*mut GDatagramBased, glib::GIOCondition, i64, *mut GCancellable) -> gboolean>,
}

pub type GDatagramBasedSourceFunc = extern "C" fn (*mut GDatagramBased, glib::GIOCondition, gpointer) -> gboolean;

pub type GDesktopAppLaunchCallback = extern "C" fn (*mut GDesktopAppInfo, glib::GPid, gpointer);

pub enum GDrive { }

#[repr(C)]
pub struct GDriveIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<extern "C" fn (*mut GDrive)>,
    pub disconnected: Option<extern "C" fn (*mut GDrive)>,
    pub eject_button: Option<extern "C" fn (*mut GDrive)>,
    pub get_name: Option<extern "C" fn (*mut GDrive) -> *mut gchar>,
    pub get_icon: Option<extern "C" fn (*mut GDrive) -> *mut GIcon>,
    pub has_volumes: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub get_volumes: Option<extern "C" fn (*mut GDrive) -> *mut glib::GList>,
    pub is_media_removable: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub has_media: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub is_media_check_automatic: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub can_eject: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub can_poll_for_media: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub eject: Option<extern "C" fn (*mut GDrive, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_finish: Option<extern "C" fn (*mut GDrive, *mut GAsyncResult) -> gboolean>,
    pub poll_for_media: Option<extern "C" fn (*mut GDrive, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub poll_for_media_finish: Option<extern "C" fn (*mut GDrive, *mut GAsyncResult) -> gboolean>,
    pub get_identifier: Option<extern "C" fn (*mut GDrive, *const gchar) -> *mut gchar>,
    pub enumerate_identifiers: Option<extern "C" fn (*mut GDrive) -> *mut *mut gchar>,
    pub get_start_stop_type: Option<extern "C" fn (*mut GDrive) -> GDriveStartStopType>,
    pub can_start: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub can_start_degraded: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub start: Option<extern "C" fn (*mut GDrive, GDriveStartFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub start_finish: Option<extern "C" fn (*mut GDrive, *mut GAsyncResult) -> gboolean>,
    pub can_stop: Option<extern "C" fn (*mut GDrive) -> gboolean>,
    pub stop: Option<extern "C" fn (*mut GDrive, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub stop_finish: Option<extern "C" fn (*mut GDrive, *mut GAsyncResult) -> gboolean>,
    pub stop_button: Option<extern "C" fn (*mut GDrive)>,
    pub eject_with_operation: Option<extern "C" fn (*mut GDrive, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_with_operation_finish: Option<extern "C" fn (*mut GDrive, *mut GAsyncResult) -> gboolean>,
    pub get_sort_key: Option<extern "C" fn (*mut GDrive) -> *const gchar>,
    pub get_symbolic_icon: Option<extern "C" fn (*mut GDrive) -> *mut GIcon>,
}

#[repr(C)]
pub enum GDriveStartFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_DRIVE_START_NONE: guint = 0;

#[repr(C)]
pub enum GDriveStartStopType {
    Unknown = 0,
    Shutdown = 1,
    Network = 2,
    Multidisk = 3,
    Password = 4,
}
pub const G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = GDriveStartStopType::Unknown;
pub const G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = GDriveStartStopType::Shutdown;
pub const G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = GDriveStartStopType::Network;
pub const G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = GDriveStartStopType::Multidisk;
pub const G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = GDriveStartStopType::Password;

pub enum GEmblem { }

#[repr(C)]
pub struct GEmblemClass(gpointer);

#[repr(C)]
pub enum GEmblemOrigin {
    Unknown = 0,
    Device = 1,
    Livemetadata = 2,
    Tag = 3,
}
pub const G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = GEmblemOrigin::Unknown;
pub const G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = GEmblemOrigin::Device;
pub const G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = GEmblemOrigin::Livemetadata;
pub const G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = GEmblemOrigin::Tag;

#[repr(C)]
pub struct GEmblemedIcon {
    pub parent_instance: gobject::GObject,
    priv_: *mut GEmblemedIconPrivate,
}

#[repr(C)]
pub struct GEmblemedIconClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GEmblemedIconPrivate(gpointer);

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &'static [u8] = b"access::can-delete\0";

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &'static [u8] = b"access::can-execute\0";

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &'static [u8] = b"access::can-read\0";

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &'static [u8] = b"access::can-rename\0";

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &'static [u8] = b"access::can-trash\0";

pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &'static [u8] = b"access::can-write\0";

pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &'static [u8] = b"dos::is-archive\0";

pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &'static [u8] = b"dos::is-system\0";

pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &'static [u8] = b"etag::value\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &'static [u8] = b"filesystem::free\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &'static [u8] = b"filesystem::readonly\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &'static [u8] = b"filesystem::size\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &'static [u8] = b"filesystem::type\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &'static [u8] = b"filesystem::used\0";

pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &'static [u8] = b"filesystem::use-preview\0";

pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &'static [u8] = b"gvfs::backend\0";

pub const G_FILE_ATTRIBUTE_ID_FILE: &'static [u8] = b"id::file\0";

pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &'static [u8] = b"id::filesystem\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &'static [u8] = b"mountable::can-eject\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &'static [u8] = b"mountable::can-mount\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &'static [u8] = b"mountable::can-poll\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &'static [u8] = b"mountable::can-start\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &'static [u8] = b"mountable::can-start-degraded\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &'static [u8] = b"mountable::can-stop\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &'static [u8] = b"mountable::can-unmount\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &'static [u8] = b"mountable::hal-udi\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &'static [u8] = b"mountable::is-media-check-automatic\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &'static [u8] = b"mountable::start-stop-type\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &'static [u8] = b"mountable::unix-device\0";

pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &'static [u8] = b"mountable::unix-device-file\0";

pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &'static [u8] = b"owner::group\0";

pub const G_FILE_ATTRIBUTE_OWNER_USER: &'static [u8] = b"owner::user\0";

pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &'static [u8] = b"owner::user-real\0";

pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &'static [u8] = b"preview::icon\0";

pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &'static [u8] = b"selinux::context\0";

pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &'static [u8] = b"standard::allocated-size\0";

pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &'static [u8] = b"standard::content-type\0";

pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &'static [u8] = b"standard::copy-name\0";

pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &'static [u8] = b"standard::description\0";

pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &'static [u8] = b"standard::display-name\0";

pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &'static [u8] = b"standard::edit-name\0";

pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &'static [u8] = b"standard::fast-content-type\0";

pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &'static [u8] = b"standard::icon\0";

pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &'static [u8] = b"standard::is-backup\0";

pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &'static [u8] = b"standard::is-hidden\0";

pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &'static [u8] = b"standard::is-symlink\0";

pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &'static [u8] = b"standard::is-virtual\0";

pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &'static [u8] = b"standard::is-volatile\0";

pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &'static [u8] = b"standard::name\0";

pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &'static [u8] = b"standard::size\0";

pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &'static [u8] = b"standard::sort-order\0";

pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &'static [u8] = b"standard::symbolic-icon\0";

pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &'static [u8] = b"standard::symlink-target\0";

pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &'static [u8] = b"standard::target-uri\0";

pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &'static [u8] = b"standard::type\0";

pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &'static [u8] = b"thumbnail::failed\0";

pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &'static [u8] = b"thumbnail::is-valid\0";

pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &'static [u8] = b"thumbnail::path\0";

pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &'static [u8] = b"time::access\0";

pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &'static [u8] = b"time::access-usec\0";

pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &'static [u8] = b"time::changed\0";

pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &'static [u8] = b"time::changed-usec\0";

pub const G_FILE_ATTRIBUTE_TIME_CREATED: &'static [u8] = b"time::created\0";

pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &'static [u8] = b"time::created-usec\0";

pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &'static [u8] = b"time::modified\0";

pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &'static [u8] = b"time::modified-usec\0";

pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &'static [u8] = b"trash::deletion-date\0";

pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &'static [u8] = b"trash::item-count\0";

pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &'static [u8] = b"trash::orig-path\0";

pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &'static [u8] = b"unix::blocks\0";

pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &'static [u8] = b"unix::block-size\0";

pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &'static [u8] = b"unix::device\0";

pub const G_FILE_ATTRIBUTE_UNIX_GID: &'static [u8] = b"unix::gid\0";

pub const G_FILE_ATTRIBUTE_UNIX_INODE: &'static [u8] = b"unix::inode\0";

pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &'static [u8] = b"unix::is-mountpoint\0";

pub const G_FILE_ATTRIBUTE_UNIX_MODE: &'static [u8] = b"unix::mode\0";

pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &'static [u8] = b"unix::nlink\0";

pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &'static [u8] = b"unix::rdev\0";

pub const G_FILE_ATTRIBUTE_UNIX_UID: &'static [u8] = b"unix::uid\0";

pub enum GFile { }

#[repr(C)]
pub struct GFileAttributeInfo {
    pub name: *mut gchar,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}

#[repr(C)]
pub enum GFileAttributeInfoFlags {
    None = 0,
    CopyWithFile = 1,
    CopyWhenMoved = 2,
}
pub const G_FILE_ATTRIBUTE_INFO_NONE: guint = 0;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: guint = 1;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: guint = 2;

#[repr(C)]
pub struct GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: gint,
}

pub enum GFileAttributeMatcher { }

#[repr(C)]
pub enum GFileAttributeStatus {
    Unset = 0,
    Set = 1,
    ErrorSetting = 2,
}
pub const G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = GFileAttributeStatus::Unset;
pub const G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = GFileAttributeStatus::Set;
pub const G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = GFileAttributeStatus::ErrorSetting;

#[repr(C)]
pub enum GFileAttributeType {
    Invalid = 0,
    String = 1,
    ByteString = 2,
    Boolean = 3,
    Uint32 = 4,
    Int32 = 5,
    Uint64 = 6,
    Int64 = 7,
    Object = 8,
    Stringv = 9,
}
pub const G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = GFileAttributeType::Invalid;
pub const G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = GFileAttributeType::String;
pub const G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = GFileAttributeType::ByteString;
pub const G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = GFileAttributeType::Boolean;
pub const G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = GFileAttributeType::Uint32;
pub const G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = GFileAttributeType::Int32;
pub const G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = GFileAttributeType::Uint64;
pub const G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = GFileAttributeType::Int64;
pub const G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = GFileAttributeType::Object;
pub const G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = GFileAttributeType::Stringv;

#[repr(C)]
pub enum GFileCopyFlags {
    None = 0,
    Overwrite = 1,
    Backup = 2,
    NofollowSymlinks = 4,
    AllMetadata = 8,
    NoFallbackForMove = 16,
    TargetDefaultPerms = 32,
}
pub const G_FILE_COPY_NONE: guint = 0;
pub const G_FILE_COPY_OVERWRITE: guint = 1;
pub const G_FILE_COPY_BACKUP: guint = 2;
pub const G_FILE_COPY_NOFOLLOW_SYMLINKS: guint = 4;
pub const G_FILE_COPY_ALL_METADATA: guint = 8;
pub const G_FILE_COPY_NO_FALLBACK_FOR_MOVE: guint = 16;
pub const G_FILE_COPY_TARGET_DEFAULT_PERMS: guint = 32;

#[repr(C)]
pub enum GFileCreateFlags {
    None = 0,
    Private = 1,
    ReplaceDestination = 2,
}
pub const G_FILE_CREATE_NONE: guint = 0;
pub const G_FILE_CREATE_PRIVATE: guint = 1;
pub const G_FILE_CREATE_REPLACE_DESTINATION: guint = 2;

#[repr(C)]
pub struct GFileEnumerator {
    pub parent_instance: gobject::GObject,
    priv_: *mut GFileEnumeratorPrivate,
}

#[repr(C)]
pub struct GFileEnumeratorClass {
    pub parent_class: gobject::GObjectClass,
    pub next_file: Option<extern "C" fn (*mut GFileEnumerator, *mut GCancellable) -> *mut GFileInfo>,
    pub close_fn: Option<extern "C" fn (*mut GFileEnumerator, *mut GCancellable) -> gboolean>,
    pub next_files_async: Option<extern "C" fn (*mut GFileEnumerator, gint, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub next_files_finish: Option<extern "C" fn (*mut GFileEnumerator, *mut GAsyncResult) -> *mut glib::GList>,
    pub close_async: Option<extern "C" fn (*mut GFileEnumerator, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub close_finish: Option<extern "C" fn (*mut GFileEnumerator, *mut GAsyncResult) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GFileEnumeratorPrivate(gpointer);

#[repr(C)]
pub struct GFileIOStream {
    pub parent_instance: GIOStream,
    priv_: *mut GFileIOStreamPrivate,
}

#[repr(C)]
pub struct GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: Option<extern "C" fn (*mut GFileIOStream) -> i64>,
    pub can_seek: Option<extern "C" fn (*mut GFileIOStream) -> gboolean>,
    pub seek: Option<extern "C" fn (*mut GFileIOStream, i64, glib::GSeekType, *mut GCancellable) -> gboolean>,
    pub can_truncate: Option<extern "C" fn (*mut GFileIOStream) -> gboolean>,
    pub truncate_fn: Option<extern "C" fn (*mut GFileIOStream, i64, *mut GCancellable) -> gboolean>,
    pub query_info: Option<extern "C" fn (*mut GFileIOStream, *const gchar, *mut GCancellable) -> *mut GFileInfo>,
    pub query_info_async: Option<extern "C" fn (*mut GFileIOStream, *const gchar, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub query_info_finish: Option<extern "C" fn (*mut GFileIOStream, *mut GAsyncResult) -> *mut GFileInfo>,
    pub get_etag: Option<extern "C" fn (*mut GFileIOStream) -> *mut gchar>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GFileIOStreamPrivate(gpointer);

pub enum GFileIcon { }

#[repr(C)]
pub struct GFileIconClass(gpointer);

#[repr(C)]
pub struct GFileIface {
    pub g_iface: gobject::GTypeInterface,
    pub dup: Option<extern "C" fn (*mut GFile) -> *mut GFile>,
    pub hash: Option<extern "C" fn (*mut GFile) -> guint>,
    pub equal: Option<extern "C" fn (*mut GFile, *mut GFile) -> gboolean>,
    pub is_native: Option<extern "C" fn (*mut GFile) -> gboolean>,
    pub has_uri_scheme: Option<extern "C" fn (*mut GFile, *const gchar) -> gboolean>,
    pub get_uri_scheme: Option<extern "C" fn (*mut GFile) -> *mut gchar>,
    pub get_basename: Option<extern "C" fn (*mut GFile) -> *mut gchar>,
    pub get_path: Option<extern "C" fn (*mut GFile) -> *mut gchar>,
    pub get_uri: Option<extern "C" fn (*mut GFile) -> *mut gchar>,
    pub get_parse_name: Option<extern "C" fn (*mut GFile) -> *mut gchar>,
    pub get_parent: Option<extern "C" fn (*mut GFile) -> *mut GFile>,
    pub prefix_matches: Option<extern "C" fn (*mut GFile, *mut GFile) -> gboolean>,
    pub get_relative_path: Option<extern "C" fn (*mut GFile, *mut GFile) -> *mut gchar>,
    pub resolve_relative_path: Option<extern "C" fn (*mut GFile, *const gchar) -> *mut GFile>,
    pub get_child_for_display_name: Option<extern "C" fn (*mut GFile, *const gchar) -> *mut GFile>,
    pub enumerate_children: Option<extern "C" fn (*mut GFile, *const gchar, GFileQueryInfoFlags, *mut GCancellable) -> *mut GFileEnumerator>,
    pub enumerate_children_async: Option<extern "C" fn (*mut GFile, *const gchar, GFileQueryInfoFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub enumerate_children_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileEnumerator>,
    pub query_info: Option<extern "C" fn (*mut GFile, *const gchar, GFileQueryInfoFlags, *mut GCancellable) -> *mut GFileInfo>,
    pub query_info_async: Option<extern "C" fn (*mut GFile, *const gchar, GFileQueryInfoFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub query_info_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileInfo>,
    pub query_filesystem_info: Option<extern "C" fn (*mut GFile, *const gchar, *mut GCancellable) -> *mut GFileInfo>,
    pub query_filesystem_info_async: Option<extern "C" fn (*mut GFile, *const gchar, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub query_filesystem_info_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileInfo>,
    pub find_enclosing_mount: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> *mut GMount>,
    pub find_enclosing_mount_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub find_enclosing_mount_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GMount>,
    pub set_display_name: Option<extern "C" fn (*mut GFile, *const gchar, *mut GCancellable) -> *mut GFile>,
    pub set_display_name_async: Option<extern "C" fn (*mut GFile, *const gchar, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub set_display_name_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFile>,
    pub query_settable_attributes: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> *mut GFileAttributeInfoList>,
    pub _query_settable_attributes_async: Option<extern "C" fn ()>,
    pub _query_settable_attributes_finish: Option<extern "C" fn ()>,
    pub query_writable_namespaces: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> *mut GFileAttributeInfoList>,
    pub _query_writable_namespaces_async: Option<extern "C" fn ()>,
    pub _query_writable_namespaces_finish: Option<extern "C" fn ()>,
    pub set_attribute: Option<extern "C" fn (*mut GFile, *const gchar, GFileAttributeType, gpointer, GFileQueryInfoFlags, *mut GCancellable) -> gboolean>,
    pub set_attributes_from_info: Option<extern "C" fn (*mut GFile, *mut GFileInfo, GFileQueryInfoFlags, *mut GCancellable) -> gboolean>,
    pub set_attributes_async: Option<extern "C" fn (*mut GFile, *mut GFileInfo, GFileQueryInfoFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub set_attributes_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult, *mut *mut GFileInfo) -> gboolean>,
    pub read_fn: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> *mut GFileInputStream>,
    pub read_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub read_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileInputStream>,
    pub append_to: Option<extern "C" fn (*mut GFile, GFileCreateFlags, *mut GCancellable) -> *mut GFileOutputStream>,
    pub append_to_async: Option<extern "C" fn (*mut GFile, GFileCreateFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub append_to_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileOutputStream>,
    pub create: Option<extern "C" fn (*mut GFile, GFileCreateFlags, *mut GCancellable) -> *mut GFileOutputStream>,
    pub create_async: Option<extern "C" fn (*mut GFile, GFileCreateFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub create_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileOutputStream>,
    pub replace: Option<extern "C" fn (*mut GFile, *const gchar, gboolean, GFileCreateFlags, *mut GCancellable) -> *mut GFileOutputStream>,
    pub replace_async: Option<extern "C" fn (*mut GFile, *const gchar, gboolean, GFileCreateFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub replace_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileOutputStream>,
    pub delete_file: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> gboolean>,
    pub delete_file_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub delete_file_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub trash: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> gboolean>,
    pub trash_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub trash_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub make_directory: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> gboolean>,
    pub make_directory_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub make_directory_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub make_symbolic_link: Option<extern "C" fn (*mut GFile, *const gchar, *mut GCancellable) -> gboolean>,
    pub _make_symbolic_link_async: Option<extern "C" fn ()>,
    pub _make_symbolic_link_finish: Option<extern "C" fn ()>,
    pub copy: Option<extern "C" fn (*mut GFile, *mut GFile, GFileCopyFlags, *mut GCancellable, Option<GFileProgressCallback>, gpointer) -> gboolean>,
    pub copy_async: Option<extern "C" fn (*mut GFile, *mut GFile, GFileCopyFlags, gint, *mut GCancellable, Option<GFileProgressCallback>, gpointer, Option<GAsyncReadyCallback>, gpointer)>,
    pub copy_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub move_: Option<extern "C" fn (*mut GFile, *mut GFile, GFileCopyFlags, *mut GCancellable, Option<GFileProgressCallback>, gpointer) -> gboolean>,
    pub _move_async: Option<extern "C" fn ()>,
    pub _move_finish: Option<extern "C" fn ()>,
    pub mount_mountable: Option<extern "C" fn (*mut GFile, GMountMountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub mount_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFile>,
    pub unmount_mountable: Option<extern "C" fn (*mut GFile, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub unmount_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub eject_mountable: Option<extern "C" fn (*mut GFile, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub mount_enclosing_volume: Option<extern "C" fn (*mut GFile, GMountMountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub mount_enclosing_volume_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub monitor_dir: Option<extern "C" fn (*mut GFile, GFileMonitorFlags, *mut GCancellable) -> *mut GFileMonitor>,
    pub monitor_file: Option<extern "C" fn (*mut GFile, GFileMonitorFlags, *mut GCancellable) -> *mut GFileMonitor>,
    pub open_readwrite: Option<extern "C" fn (*mut GFile, *mut GCancellable) -> *mut GFileIOStream>,
    pub open_readwrite_async: Option<extern "C" fn (*mut GFile, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub open_readwrite_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileIOStream>,
    pub create_readwrite: Option<extern "C" fn (*mut GFile, GFileCreateFlags, *mut GCancellable) -> *mut GFileIOStream>,
    pub create_readwrite_async: Option<extern "C" fn (*mut GFile, GFileCreateFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub create_readwrite_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileIOStream>,
    pub replace_readwrite: Option<extern "C" fn (*mut GFile, *const gchar, gboolean, GFileCreateFlags, *mut GCancellable) -> *mut GFileIOStream>,
    pub replace_readwrite_async: Option<extern "C" fn (*mut GFile, *const gchar, gboolean, GFileCreateFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub replace_readwrite_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> *mut GFileIOStream>,
    pub start_mountable: Option<extern "C" fn (*mut GFile, GDriveStartFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub start_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub stop_mountable: Option<extern "C" fn (*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub stop_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: Option<extern "C" fn (*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub unmount_mountable_with_operation_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub eject_mountable_with_operation: Option<extern "C" fn (*mut GFile, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_mountable_with_operation_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub poll_mountable: Option<extern "C" fn (*mut GFile, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub poll_mountable_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult) -> gboolean>,
    pub measure_disk_usage: Option<extern "C" fn (*mut GFile, GFileMeasureFlags, *mut GCancellable, Option<GFileMeasureProgressCallback>, gpointer, *mut u64, *mut u64, *mut u64) -> gboolean>,
    pub measure_disk_usage_async: Option<extern "C" fn (*mut GFile, GFileMeasureFlags, gint, *mut GCancellable, Option<GFileMeasureProgressCallback>, gpointer, Option<GAsyncReadyCallback>, gpointer)>,
    pub measure_disk_usage_finish: Option<extern "C" fn (*mut GFile, *mut GAsyncResult, *mut u64, *mut u64, *mut u64) -> gboolean>,
}

pub enum GFileInfo { }

#[repr(C)]
pub struct GFileInfoClass(gpointer);

#[repr(C)]
pub struct GFileInputStream {
    pub parent_instance: GInputStream,
    priv_: *mut GFileInputStreamPrivate,
}

#[repr(C)]
pub struct GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: Option<extern "C" fn (*mut GFileInputStream) -> i64>,
    pub can_seek: Option<extern "C" fn (*mut GFileInputStream) -> gboolean>,
    pub seek: Option<extern "C" fn (*mut GFileInputStream, i64, glib::GSeekType, *mut GCancellable) -> gboolean>,
    pub query_info: Option<extern "C" fn (*mut GFileInputStream, *const gchar, *mut GCancellable) -> *mut GFileInfo>,
    pub query_info_async: Option<extern "C" fn (*mut GFileInputStream, *const gchar, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub query_info_finish: Option<extern "C" fn (*mut GFileInputStream, *mut GAsyncResult) -> *mut GFileInfo>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GFileInputStreamPrivate(gpointer);

#[repr(C)]
pub enum GFileMeasureFlags {
    None = 0,
    ReportAnyError = 2,
    ApparentSize = 4,
    NoXdev = 8,
}
pub const G_FILE_MEASURE_NONE: guint = 0;
pub const G_FILE_MEASURE_REPORT_ANY_ERROR: guint = 2;
pub const G_FILE_MEASURE_APPARENT_SIZE: guint = 4;
pub const G_FILE_MEASURE_NO_XDEV: guint = 8;

pub type GFileMeasureProgressCallback = extern "C" fn (gboolean, u64, u64, u64, gpointer);

#[repr(C)]
pub struct GFileMonitor {
    pub parent_instance: gobject::GObject,
    priv_: *mut GFileMonitorPrivate,
}

#[repr(C)]
pub struct GFileMonitorClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<extern "C" fn (*mut GFileMonitor, *mut GFile, *mut GFile, GFileMonitorEvent)>,
    pub cancel: Option<extern "C" fn (*mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GFileMonitorEvent {
    Changed = 0,
    ChangesDoneHint = 1,
    Deleted = 2,
    Created = 3,
    AttributeChanged = 4,
    PreUnmount = 5,
    Unmounted = 6,
    Moved = 7,
    Renamed = 8,
    MovedIn = 9,
    MovedOut = 10,
}
pub const G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = GFileMonitorEvent::Changed;
pub const G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = GFileMonitorEvent::ChangesDoneHint;
pub const G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = GFileMonitorEvent::Deleted;
pub const G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = GFileMonitorEvent::Created;
pub const G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = GFileMonitorEvent::AttributeChanged;
pub const G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = GFileMonitorEvent::PreUnmount;
pub const G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = GFileMonitorEvent::Unmounted;
pub const G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = GFileMonitorEvent::Moved;
pub const G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = GFileMonitorEvent::Renamed;
pub const G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = GFileMonitorEvent::MovedIn;
pub const G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = GFileMonitorEvent::MovedOut;

#[repr(C)]
pub enum GFileMonitorFlags {
    None = 0,
    WatchMounts = 1,
    SendMoved = 2,
    WatchHardLinks = 4,
    WatchMoves = 8,
}
pub const G_FILE_MONITOR_NONE: guint = 0;
pub const G_FILE_MONITOR_WATCH_MOUNTS: guint = 1;
pub const G_FILE_MONITOR_SEND_MOVED: guint = 2;
pub const G_FILE_MONITOR_WATCH_HARD_LINKS: guint = 4;
pub const G_FILE_MONITOR_WATCH_MOVES: guint = 8;

#[repr(C)]
pub struct GFileMonitorPrivate(gpointer);

#[repr(C)]
pub struct GFileOutputStream {
    pub parent_instance: GOutputStream,
    priv_: *mut GFileOutputStreamPrivate,
}

#[repr(C)]
pub struct GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell: Option<extern "C" fn (*mut GFileOutputStream) -> i64>,
    pub can_seek: Option<extern "C" fn (*mut GFileOutputStream) -> gboolean>,
    pub seek: Option<extern "C" fn (*mut GFileOutputStream, i64, glib::GSeekType, *mut GCancellable) -> gboolean>,
    pub can_truncate: Option<extern "C" fn (*mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: Option<extern "C" fn (*mut GFileOutputStream, i64, *mut GCancellable) -> gboolean>,
    pub query_info: Option<extern "C" fn (*mut GFileOutputStream, *const gchar, *mut GCancellable) -> *mut GFileInfo>,
    pub query_info_async: Option<extern "C" fn (*mut GFileOutputStream, *const gchar, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub query_info_finish: Option<extern "C" fn (*mut GFileOutputStream, *mut GAsyncResult) -> *mut GFileInfo>,
    pub get_etag: Option<extern "C" fn (*mut GFileOutputStream) -> *mut gchar>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GFileOutputStreamPrivate(gpointer);

pub type GFileProgressCallback = extern "C" fn (i64, i64, gpointer);

#[repr(C)]
pub enum GFileQueryInfoFlags {
    None = 0,
    NofollowSymlinks = 1,
}
pub const G_FILE_QUERY_INFO_NONE: guint = 0;
pub const G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: guint = 1;

pub type GFileReadMoreCallback = extern "C" fn (*const gchar, i64, gpointer) -> gboolean;

#[repr(C)]
pub enum GFileType {
    Unknown = 0,
    Regular = 1,
    Directory = 2,
    SymbolicLink = 3,
    Special = 4,
    Shortcut = 5,
    Mountable = 6,
}
pub const G_FILE_TYPE_UNKNOWN: GFileType = GFileType::Unknown;
pub const G_FILE_TYPE_REGULAR: GFileType = GFileType::Regular;
pub const G_FILE_TYPE_DIRECTORY: GFileType = GFileType::Directory;
pub const G_FILE_TYPE_SYMBOLIC_LINK: GFileType = GFileType::SymbolicLink;
pub const G_FILE_TYPE_SPECIAL: GFileType = GFileType::Special;
pub const G_FILE_TYPE_SHORTCUT: GFileType = GFileType::Shortcut;
pub const G_FILE_TYPE_MOUNTABLE: GFileType = GFileType::Mountable;

pub enum GFilenameCompleter { }

#[repr(C)]
pub struct GFilenameCompleterClass {
    pub parent_class: gobject::GObjectClass,
    pub got_completion_data: Option<extern "C" fn (*mut GFilenameCompleter)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GFilesystemPreviewType {
    IfAlways = 0,
    IfLocal = 1,
    Never = 2,
}
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = GFilesystemPreviewType::IfAlways;
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = GFilesystemPreviewType::IfLocal;
pub const G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = GFilesystemPreviewType::Never;

#[repr(C)]
pub struct GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}

#[repr(C)]
pub struct GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}

#[repr(C)]
pub struct GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GIOErrorEnum {
    Failed = 0,
    NotFound = 1,
    Exists = 2,
    IsDirectory = 3,
    NotDirectory = 4,
    NotEmpty = 5,
    NotRegularFile = 6,
    NotSymbolicLink = 7,
    NotMountableFile = 8,
    FilenameTooLong = 9,
    InvalidFilename = 10,
    TooManyLinks = 11,
    NoSpace = 12,
    InvalidArgument = 13,
    PermissionDenied = 14,
    NotSupported = 15,
    NotMounted = 16,
    AlreadyMounted = 17,
    Closed = 18,
    Cancelled = 19,
    Pending = 20,
    ReadOnly = 21,
    CantCreateBackup = 22,
    WrongEtag = 23,
    TimedOut = 24,
    WouldRecurse = 25,
    Busy = 26,
    WouldBlock = 27,
    HostNotFound = 28,
    WouldMerge = 29,
    FailedHandled = 30,
    TooManyOpenFiles = 31,
    NotInitialized = 32,
    AddressInUse = 33,
    PartialInput = 34,
    InvalidData = 35,
    DbusError = 36,
    HostUnreachable = 37,
    NetworkUnreachable = 38,
    ConnectionRefused = 39,
    ProxyFailed = 40,
    ProxyAuthFailed = 41,
    ProxyNeedAuth = 42,
    ProxyNotAllowed = 43,
    BrokenPipe = 44,
    NotConnected = 45,
    MessageTooLarge = 46,
}
pub const G_IO_ERROR_FAILED: GIOErrorEnum = GIOErrorEnum::Failed;
pub const G_IO_ERROR_NOT_FOUND: GIOErrorEnum = GIOErrorEnum::NotFound;
pub const G_IO_ERROR_EXISTS: GIOErrorEnum = GIOErrorEnum::Exists;
pub const G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = GIOErrorEnum::IsDirectory;
pub const G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = GIOErrorEnum::NotDirectory;
pub const G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = GIOErrorEnum::NotEmpty;
pub const G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = GIOErrorEnum::NotRegularFile;
pub const G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = GIOErrorEnum::NotSymbolicLink;
pub const G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = GIOErrorEnum::NotMountableFile;
pub const G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = GIOErrorEnum::FilenameTooLong;
pub const G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = GIOErrorEnum::InvalidFilename;
pub const G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = GIOErrorEnum::TooManyLinks;
pub const G_IO_ERROR_NO_SPACE: GIOErrorEnum = GIOErrorEnum::NoSpace;
pub const G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = GIOErrorEnum::InvalidArgument;
pub const G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = GIOErrorEnum::PermissionDenied;
pub const G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = GIOErrorEnum::NotSupported;
pub const G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = GIOErrorEnum::NotMounted;
pub const G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = GIOErrorEnum::AlreadyMounted;
pub const G_IO_ERROR_CLOSED: GIOErrorEnum = GIOErrorEnum::Closed;
pub const G_IO_ERROR_CANCELLED: GIOErrorEnum = GIOErrorEnum::Cancelled;
pub const G_IO_ERROR_PENDING: GIOErrorEnum = GIOErrorEnum::Pending;
pub const G_IO_ERROR_READ_ONLY: GIOErrorEnum = GIOErrorEnum::ReadOnly;
pub const G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = GIOErrorEnum::CantCreateBackup;
pub const G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = GIOErrorEnum::WrongEtag;
pub const G_IO_ERROR_TIMED_OUT: GIOErrorEnum = GIOErrorEnum::TimedOut;
pub const G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = GIOErrorEnum::WouldRecurse;
pub const G_IO_ERROR_BUSY: GIOErrorEnum = GIOErrorEnum::Busy;
pub const G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = GIOErrorEnum::WouldBlock;
pub const G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = GIOErrorEnum::HostNotFound;
pub const G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = GIOErrorEnum::WouldMerge;
pub const G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = GIOErrorEnum::FailedHandled;
pub const G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = GIOErrorEnum::TooManyOpenFiles;
pub const G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = GIOErrorEnum::NotInitialized;
pub const G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = GIOErrorEnum::AddressInUse;
pub const G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = GIOErrorEnum::PartialInput;
pub const G_IO_ERROR_INVALID_DATA: GIOErrorEnum = GIOErrorEnum::InvalidData;
pub const G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = GIOErrorEnum::DbusError;
pub const G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = GIOErrorEnum::HostUnreachable;
pub const G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = GIOErrorEnum::NetworkUnreachable;
pub const G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = GIOErrorEnum::ConnectionRefused;
pub const G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = GIOErrorEnum::ProxyFailed;
pub const G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = GIOErrorEnum::ProxyAuthFailed;
pub const G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = GIOErrorEnum::ProxyNeedAuth;
pub const G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = GIOErrorEnum::ProxyNotAllowed;
pub const G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = GIOErrorEnum::BrokenPipe;
pub const G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = GIOErrorEnum::BrokenPipe;
pub const G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = GIOErrorEnum::NotConnected;
pub const G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = GIOErrorEnum::MessageTooLarge;

#[repr(C)]
pub struct GIOExtension(gpointer);

#[repr(C)]
pub struct GIOExtensionPoint(gpointer);

pub enum GIOModule { }

#[repr(C)]
pub struct GIOModuleClass(gpointer);

#[repr(C)]
pub struct GIOModuleScope(gpointer);

#[repr(C)]
pub enum GIOModuleScopeFlags {
    None = 0,
    BlockDuplicates = 1,
}
pub const G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = GIOModuleScopeFlags::None;
pub const G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = GIOModuleScopeFlags::BlockDuplicates;

#[repr(C)]
pub struct GIOSchedulerJob(gpointer);

pub type GIOSchedulerJobFunc = extern "C" fn (*mut GIOSchedulerJob, *mut GCancellable, gpointer) -> gboolean;

#[repr(C)]
pub struct GIOStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GIOStreamPrivate,
}

#[repr(C)]
pub struct GIOStreamAdapter(gpointer);

#[repr(C)]
pub struct GIOStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub get_input_stream: Option<extern "C" fn (*mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream: Option<extern "C" fn (*mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: Option<extern "C" fn (*mut GIOStream, *mut GCancellable) -> gboolean>,
    pub close_async: Option<extern "C" fn (*mut GIOStream, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub close_finish: Option<extern "C" fn (*mut GIOStream, *mut GAsyncResult) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
    pub _g_reserved8: Option<extern "C" fn ()>,
    pub _g_reserved9: Option<extern "C" fn ()>,
    pub _g_reserved10: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GIOStreamPrivate(gpointer);

#[repr(C)]
pub enum GIOStreamSpliceFlags {
    None = 0,
    CloseStream1 = 1,
    CloseStream2 = 2,
    WaitForBoth = 4,
}
pub const G_IO_STREAM_SPLICE_NONE: guint = 0;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM1: guint = 1;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM2: guint = 2;
pub const G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: guint = 4;

pub enum GIcon { }

#[repr(C)]
pub struct GIconIface {
    pub g_iface: gobject::GTypeInterface,
    pub hash: Option<extern "C" fn (*mut GIcon) -> guint>,
    pub equal: Option<extern "C" fn (*mut GIcon, *mut GIcon) -> gboolean>,
    pub to_tokens: Option<extern "C" fn (*mut GIcon, *mut glib::GPtrArray, gint) -> gboolean>,
    pub from_tokens: Option<extern "C" fn (*mut *mut gchar, gint, gint) -> *mut GIcon>,
    pub serialize: Option<extern "C" fn (*mut GIcon) -> *mut glib::GVariant>,
}

#[repr(C)]
pub struct GInetAddress {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInetAddressPrivate,
}

#[repr(C)]
pub struct GInetAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub to_string: Option<extern "C" fn (*mut GInetAddress) -> *mut gchar>,
    pub to_bytes: Option<extern "C" fn (*mut GInetAddress) -> u8>,
}

#[repr(C)]
pub struct GInetAddressMask {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInetAddressMaskPrivate,
}

#[repr(C)]
pub struct GInetAddressMaskClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GInetAddressMaskPrivate(gpointer);

#[repr(C)]
pub struct GInetAddressPrivate(gpointer);

#[repr(C)]
pub struct GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    priv_: *mut GInetSocketAddressPrivate,
}

#[repr(C)]
pub struct GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}

#[repr(C)]
pub struct GInetSocketAddressPrivate(gpointer);

pub enum GInitable { }

#[repr(C)]
pub struct GInitableIface {
    pub g_iface: gobject::GTypeInterface,
    pub init: Option<extern "C" fn (*mut GInitable, *mut GCancellable) -> gboolean>,
}

#[repr(C)]
pub struct GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: guint,
    pub bytes_received: gsize,
    pub flags: gint,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}

#[repr(C)]
pub struct GInputStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GInputStreamPrivate,
}

#[repr(C)]
pub struct GInputStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub read_fn: Option<extern "C" fn (*mut GInputStream, gpointer, gsize, *mut GCancellable) -> gssize>,
    pub skip: Option<extern "C" fn (*mut GInputStream, gsize, *mut GCancellable) -> gssize>,
    pub close_fn: Option<extern "C" fn (*mut GInputStream, *mut GCancellable) -> gboolean>,
    pub read_async: Option<extern "C" fn (*mut GInputStream, *mut u8, gsize, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub read_finish: Option<extern "C" fn (*mut GInputStream, *mut GAsyncResult) -> gssize>,
    pub skip_async: Option<extern "C" fn (*mut GInputStream, gsize, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub skip_finish: Option<extern "C" fn (*mut GInputStream, *mut GAsyncResult) -> gssize>,
    pub close_async: Option<extern "C" fn (*mut GInputStream, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub close_finish: Option<extern "C" fn (*mut GInputStream, *mut GAsyncResult) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GInputStreamPrivate(gpointer);

#[repr(C)]
pub struct GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}

pub enum GListModel { }

#[repr(C)]
pub struct GListModelInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_item_type: Option<extern "C" fn (*mut GListModel) -> GType>,
    pub get_n_items: Option<extern "C" fn (*mut GListModel) -> guint>,
    pub get_item: Option<extern "C" fn (*mut GListModel, guint) -> gpointer>,
}

pub enum GListStore { }

#[repr(C)]
pub struct GListStoreClass {
    pub parent_class: gobject::GObjectClass,
}

pub enum GLoadableIcon { }

#[repr(C)]
pub struct GLoadableIconIface {
    pub g_iface: gobject::GTypeInterface,
    pub load: Option<extern "C" fn (*mut GLoadableIcon, gint, *mut *mut gchar, *mut GCancellable) -> *mut GInputStream>,
    pub load_async: Option<extern "C" fn (*mut GLoadableIcon, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub load_finish: Option<extern "C" fn (*mut GLoadableIcon, *mut GAsyncResult, *mut *mut gchar) -> *mut GInputStream>,
}

pub const G_MENU_ATTRIBUTE_ACTION: &'static [u8] = b"action\0";

pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &'static [u8] = b"action-namespace\0";

pub const G_MENU_ATTRIBUTE_ICON: &'static [u8] = b"icon\0";

pub const G_MENU_ATTRIBUTE_LABEL: &'static [u8] = b"label\0";

pub const G_MENU_ATTRIBUTE_TARGET: &'static [u8] = b"target\0";

pub const G_MENU_LINK_SECTION: &'static [u8] = b"section\0";

pub const G_MENU_LINK_SUBMENU: &'static [u8] = b"submenu\0";

#[repr(C)]
pub struct GMemoryInputStream {
    pub parent_instance: GInputStream,
    priv_: *mut GMemoryInputStreamPrivate,
}

#[repr(C)]
pub struct GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GMemoryInputStreamPrivate(gpointer);

#[repr(C)]
pub struct GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    priv_: *mut GMemoryOutputStreamPrivate,
}

#[repr(C)]
pub struct GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GMemoryOutputStreamPrivate(gpointer);

pub enum GMenu { }

#[repr(C)]
pub struct GMenuAttributeIter {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}

#[repr(C)]
pub struct GMenuAttributeIterClass {
    pub parent_class: gobject::GObjectClass,
    pub get_next: Option<extern "C" fn (*mut GMenuAttributeIter, *mut *const gchar, *mut *mut glib::GVariant) -> gboolean>,
}

#[repr(C)]
pub struct GMenuAttributeIterPrivate(gpointer);

pub enum GMenuItem { }

#[repr(C)]
pub struct GMenuLinkIter {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}

#[repr(C)]
pub struct GMenuLinkIterClass {
    pub parent_class: gobject::GObjectClass,
    pub get_next: Option<extern "C" fn (*mut GMenuLinkIter, *mut *const gchar, *mut *mut GMenuModel) -> gboolean>,
}

#[repr(C)]
pub struct GMenuLinkIterPrivate(gpointer);

#[repr(C)]
pub struct GMenuModel {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMenuModelPrivate,
}

#[repr(C)]
pub struct GMenuModelClass {
    pub parent_class: gobject::GObjectClass,
    pub is_mutable: Option<extern "C" fn (*mut GMenuModel) -> gboolean>,
    pub get_n_items: Option<extern "C" fn (*mut GMenuModel) -> gint>,
    pub get_item_attributes: Option<extern "C" fn (*mut GMenuModel, gint, *mut *mut glib::GHashTable)>,
    pub iterate_item_attributes: Option<extern "C" fn (*mut GMenuModel, gint) -> *mut GMenuAttributeIter>,
    pub get_item_attribute_value: Option<extern "C" fn (*mut GMenuModel, gint, *const gchar, *const glib::GVariantType) -> *mut glib::GVariant>,
    pub get_item_links: Option<extern "C" fn (*mut GMenuModel, gint, *mut *mut glib::GHashTable)>,
    pub iterate_item_links: Option<extern "C" fn (*mut GMenuModel, gint) -> *mut GMenuLinkIter>,
    pub get_item_link: Option<extern "C" fn (*mut GMenuModel, gint, *const gchar) -> *mut GMenuModel>,
}

#[repr(C)]
pub struct GMenuModelPrivate(gpointer);

pub enum GMount { }

#[repr(C)]
pub struct GMountIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<extern "C" fn (*mut GMount)>,
    pub unmounted: Option<extern "C" fn (*mut GMount)>,
    pub get_root: Option<extern "C" fn (*mut GMount) -> *mut GFile>,
    pub get_name: Option<extern "C" fn (*mut GMount) -> *mut gchar>,
    pub get_icon: Option<extern "C" fn (*mut GMount) -> *mut GIcon>,
    pub get_uuid: Option<extern "C" fn (*mut GMount) -> *mut gchar>,
    pub get_volume: Option<extern "C" fn (*mut GMount) -> *mut GVolume>,
    pub get_drive: Option<extern "C" fn (*mut GMount) -> *mut GDrive>,
    pub can_unmount: Option<extern "C" fn (*mut GMount) -> gboolean>,
    pub can_eject: Option<extern "C" fn (*mut GMount) -> gboolean>,
    pub unmount: Option<extern "C" fn (*mut GMount, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub unmount_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> gboolean>,
    pub eject: Option<extern "C" fn (*mut GMount, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> gboolean>,
    pub remount: Option<extern "C" fn (*mut GMount, GMountMountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub remount_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> gboolean>,
    pub guess_content_type: Option<extern "C" fn (*mut GMount, gboolean, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub guess_content_type_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> *mut *mut gchar>,
    pub guess_content_type_sync: Option<extern "C" fn (*mut GMount, gboolean, *mut GCancellable) -> *mut *mut gchar>,
    pub pre_unmount: Option<extern "C" fn (*mut GMount)>,
    pub unmount_with_operation: Option<extern "C" fn (*mut GMount, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub unmount_with_operation_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> gboolean>,
    pub eject_with_operation: Option<extern "C" fn (*mut GMount, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_with_operation_finish: Option<extern "C" fn (*mut GMount, *mut GAsyncResult) -> gboolean>,
    pub get_default_location: Option<extern "C" fn (*mut GMount) -> *mut GFile>,
    pub get_sort_key: Option<extern "C" fn (*mut GMount) -> *const gchar>,
    pub get_symbolic_icon: Option<extern "C" fn (*mut GMount) -> *mut GIcon>,
}

#[repr(C)]
pub enum GMountMountFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_MOUNT_MOUNT_NONE: guint = 0;

#[repr(C)]
pub struct GMountOperation {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GMountOperationPrivate,
}

#[repr(C)]
pub struct GMountOperationClass {
    pub parent_class: gobject::GObjectClass,
    pub ask_password: Option<extern "C" fn (*mut GMountOperation, *const gchar, *const gchar, *const gchar, GAskPasswordFlags)>,
    pub ask_question: Option<extern "C" fn (*mut GMountOperation, *const gchar, *const gchar)>,
    pub reply: Option<extern "C" fn (*mut GMountOperation, GMountOperationResult)>,
    pub aborted: Option<extern "C" fn (*mut GMountOperation)>,
    pub show_processes: Option<extern "C" fn (*mut GMountOperation, *const gchar, *mut glib::GArray, *const gchar)>,
    pub show_unmount_progress: Option<extern "C" fn (*mut GMountOperation, *const gchar, i64, i64)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
    pub _g_reserved8: Option<extern "C" fn ()>,
    pub _g_reserved9: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GMountOperationPrivate(gpointer);

#[repr(C)]
pub enum GMountOperationResult {
    Handled = 0,
    Aborted = 1,
    Unhandled = 2,
}
pub const G_MOUNT_OPERATION_HANDLED: GMountOperationResult = GMountOperationResult::Handled;
pub const G_MOUNT_OPERATION_ABORTED: GMountOperationResult = GMountOperationResult::Aborted;
pub const G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = GMountOperationResult::Unhandled;

#[repr(C)]
pub enum GMountUnmountFlags {
    None = 0,
    Force = 1,
}
pub const G_MOUNT_UNMOUNT_NONE: guint = 0;
pub const G_MOUNT_UNMOUNT_FORCE: guint = 1;

pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static [u8] = b"gio-native-volume-monitor\0";

pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &'static [u8] = b"gio-network-monitor\0";

#[repr(C)]
pub struct GNativeSocketAddress(gpointer);

#[repr(C)]
pub struct GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}

#[repr(C)]
pub struct GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: Option<extern "C" fn (*const gchar, *mut GCancellable) -> *mut GMount>,
}

#[repr(C)]
pub struct GNetworkAddress {
    pub parent_instance: gobject::GObject,
    priv_: *mut GNetworkAddressPrivate,
}

#[repr(C)]
pub struct GNetworkAddressClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GNetworkAddressPrivate(gpointer);

#[repr(C)]
pub enum GNetworkConnectivity {
    Local = 1,
    Limited = 2,
    Portal = 3,
    Full = 4,
}
pub const G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = GNetworkConnectivity::Local;
pub const G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = GNetworkConnectivity::Limited;
pub const G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = GNetworkConnectivity::Portal;
pub const G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = GNetworkConnectivity::Full;

pub enum GNetworkMonitor { }

#[repr(C)]
pub struct GNetworkMonitorInterface {
    pub g_iface: gobject::GTypeInterface,
    pub network_changed: Option<extern "C" fn (*mut GNetworkMonitor, gboolean)>,
    pub can_reach: Option<extern "C" fn (*mut GNetworkMonitor, *mut GSocketConnectable, *mut GCancellable) -> gboolean>,
    pub can_reach_async: Option<extern "C" fn (*mut GNetworkMonitor, *mut GSocketConnectable, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub can_reach_finish: Option<extern "C" fn (*mut GNetworkMonitor, *mut GAsyncResult) -> gboolean>,
}

#[repr(C)]
pub struct GNetworkService {
    pub parent_instance: gobject::GObject,
    priv_: *mut GNetworkServicePrivate,
}

#[repr(C)]
pub struct GNetworkServiceClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct GNetworkServicePrivate(gpointer);

pub enum GNotification { }

#[repr(C)]
pub enum GNotificationPriority {
    Normal = 0,
    Low = 1,
    High = 2,
    Urgent = 3,
}
pub const G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = GNotificationPriority::Normal;
pub const G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = GNotificationPriority::Low;
pub const G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = GNotificationPriority::High;
pub const G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = GNotificationPriority::Urgent;

#[repr(C)]
pub struct GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}

#[repr(C)]
pub struct GOutputStream {
    pub parent_instance: gobject::GObject,
    priv_: *mut GOutputStreamPrivate,
}

#[repr(C)]
pub struct GOutputStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub write_fn: Option<extern "C" fn (*mut GOutputStream, *mut u8, gsize, *mut GCancellable) -> gssize>,
    pub splice: Option<extern "C" fn (*mut GOutputStream, *mut GInputStream, GOutputStreamSpliceFlags, *mut GCancellable) -> gssize>,
    pub flush: Option<extern "C" fn (*mut GOutputStream, *mut GCancellable) -> gboolean>,
    pub close_fn: Option<extern "C" fn (*mut GOutputStream, *mut GCancellable) -> gboolean>,
    pub write_async: Option<extern "C" fn (*mut GOutputStream, *mut u8, gsize, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub write_finish: Option<extern "C" fn (*mut GOutputStream, *mut GAsyncResult) -> gssize>,
    pub splice_async: Option<extern "C" fn (*mut GOutputStream, *mut GInputStream, GOutputStreamSpliceFlags, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub splice_finish: Option<extern "C" fn (*mut GOutputStream, *mut GAsyncResult) -> gssize>,
    pub flush_async: Option<extern "C" fn (*mut GOutputStream, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub flush_finish: Option<extern "C" fn (*mut GOutputStream, *mut GAsyncResult) -> gboolean>,
    pub close_async: Option<extern "C" fn (*mut GOutputStream, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub close_finish: Option<extern "C" fn (*mut GOutputStream, *mut GAsyncResult) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
    pub _g_reserved8: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GOutputStreamPrivate(gpointer);

#[repr(C)]
pub enum GOutputStreamSpliceFlags {
    None = 0,
    CloseSource = 1,
    CloseTarget = 2,
}
pub const G_OUTPUT_STREAM_SPLICE_NONE: guint = 0;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: guint = 1;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: guint = 2;

#[repr(C)]
pub struct GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}

pub const G_PROXY_EXTENSION_POINT_NAME: &'static [u8] = b"gio-proxy\0";

pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &'static [u8] = b"gio-proxy-resolver\0";

#[repr(C)]
pub enum GPasswordSave {
    Never = 0,
    ForSession = 1,
    Permanently = 2,
}
pub const G_PASSWORD_SAVE_NEVER: GPasswordSave = GPasswordSave::Never;
pub const G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = GPasswordSave::ForSession;
pub const G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = GPasswordSave::Permanently;

#[repr(C)]
pub struct GPermission {
    pub parent_instance: gobject::GObject,
    priv_: *mut GPermissionPrivate,
}

#[repr(C)]
pub struct GPermissionClass {
    pub parent_class: gobject::GObjectClass,
    pub acquire: Option<extern "C" fn (*mut GPermission, *mut GCancellable) -> gboolean>,
    pub acquire_async: Option<extern "C" fn (*mut GPermission, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub acquire_finish: Option<extern "C" fn (*mut GPermission, *mut GAsyncResult) -> gboolean>,
    pub release: Option<extern "C" fn (*mut GPermission, *mut GCancellable) -> gboolean>,
    pub release_async: Option<extern "C" fn (*mut GPermission, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub release_finish: Option<extern "C" fn (*mut GPermission, *mut GAsyncResult) -> gboolean>,
    pub reserved: [gpointer; 16],
}

#[repr(C)]
pub struct GPermissionPrivate(gpointer);

pub enum GPollableInputStream { }

#[repr(C)]
pub struct GPollableInputStreamInterface {
    pub g_iface: gobject::GTypeInterface,
    pub can_poll: Option<extern "C" fn (*mut GPollableInputStream) -> gboolean>,
    pub is_readable: Option<extern "C" fn (*mut GPollableInputStream) -> gboolean>,
    pub create_source: Option<extern "C" fn (*mut GPollableInputStream, *mut GCancellable) -> *mut glib::GSource>,
    pub read_nonblocking: Option<extern "C" fn (*mut GPollableInputStream, *mut u8, gsize) -> gssize>,
}

pub enum GPollableOutputStream { }

#[repr(C)]
pub struct GPollableOutputStreamInterface {
    pub g_iface: gobject::GTypeInterface,
    pub can_poll: Option<extern "C" fn (*mut GPollableOutputStream) -> gboolean>,
    pub is_writable: Option<extern "C" fn (*mut GPollableOutputStream) -> gboolean>,
    pub create_source: Option<extern "C" fn (*mut GPollableOutputStream, *mut GCancellable) -> *mut glib::GSource>,
    pub write_nonblocking: Option<extern "C" fn (*mut GPollableOutputStream, *mut u8, gsize) -> gssize>,
}

pub type GPollableSourceFunc = extern "C" fn (*mut gobject::GObject, gpointer) -> gboolean;

pub enum GPropertyAction { }

pub enum GProxy { }

#[repr(C)]
pub struct GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    priv_: *mut GProxyAddressPrivate,
}

#[repr(C)]
pub struct GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}

#[repr(C)]
pub struct GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}

#[repr(C)]
pub struct GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GProxyAddressEnumeratorPrivate(gpointer);

#[repr(C)]
pub struct GProxyAddressPrivate(gpointer);

#[repr(C)]
pub struct GProxyInterface {
    pub g_iface: gobject::GTypeInterface,
    pub connect: Option<extern "C" fn (*mut GProxy, *mut GIOStream, *mut GProxyAddress, *mut GCancellable) -> *mut GIOStream>,
    pub connect_async: Option<extern "C" fn (*mut GProxy, *mut GIOStream, *mut GProxyAddress, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub connect_finish: Option<extern "C" fn (*mut GProxy, *mut GAsyncResult) -> *mut GIOStream>,
    pub supports_hostname: Option<extern "C" fn (*mut GProxy) -> gboolean>,
}

pub enum GProxyResolver { }

#[repr(C)]
pub struct GProxyResolverInterface {
    pub g_iface: gobject::GTypeInterface,
    pub is_supported: Option<extern "C" fn (*mut GProxyResolver) -> gboolean>,
    pub lookup: Option<extern "C" fn (*mut GProxyResolver, *const gchar, *mut GCancellable) -> *mut *mut gchar>,
    pub lookup_async: Option<extern "C" fn (*mut GProxyResolver, *const gchar, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_finish: Option<extern "C" fn (*mut GProxyResolver, *mut GAsyncResult) -> *mut *mut gchar>,
}

pub type GReallocFunc = extern "C" fn (gpointer, gsize) -> gpointer;

pub enum GRemoteActionGroup { }

#[repr(C)]
pub struct GRemoteActionGroupInterface {
    pub g_iface: gobject::GTypeInterface,
    pub activate_action_full: Option<extern "C" fn (*mut GRemoteActionGroup, *const gchar, *mut glib::GVariant, *mut glib::GVariant)>,
    pub change_action_state_full: Option<extern "C" fn (*mut GRemoteActionGroup, *const gchar, *mut glib::GVariant, *mut glib::GVariant)>,
}

#[repr(C)]
pub struct GResolver {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GResolverPrivate,
}

#[repr(C)]
pub struct GResolverClass {
    pub parent_class: gobject::GObjectClass,
    pub reload: Option<extern "C" fn (*mut GResolver)>,
    pub lookup_by_name: Option<extern "C" fn (*mut GResolver, *const gchar, *mut GCancellable) -> *mut glib::GList>,
    pub lookup_by_name_async: Option<extern "C" fn (*mut GResolver, *const gchar, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_by_name_finish: Option<extern "C" fn (*mut GResolver, *mut GAsyncResult) -> *mut glib::GList>,
    pub lookup_by_address: Option<extern "C" fn (*mut GResolver, *mut GInetAddress, *mut GCancellable) -> *mut gchar>,
    pub lookup_by_address_async: Option<extern "C" fn (*mut GResolver, *mut GInetAddress, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_by_address_finish: Option<extern "C" fn (*mut GResolver, *mut GAsyncResult) -> *mut gchar>,
    pub lookup_service: Option<extern "C" fn (*mut GResolver, *const gchar, *mut GCancellable) -> *mut glib::GList>,
    pub lookup_service_async: Option<extern "C" fn (*mut GResolver, *const gchar, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_service_finish: Option<extern "C" fn (*mut GResolver, *mut GAsyncResult) -> *mut glib::GList>,
    pub lookup_records: Option<extern "C" fn (*mut GResolver, *const gchar, GResolverRecordType, *mut GCancellable) -> *mut glib::GList>,
    pub lookup_records_async: Option<extern "C" fn (*mut GResolver, *const gchar, GResolverRecordType, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_records_finish: Option<extern "C" fn (*mut GResolver, *mut GAsyncResult) -> *mut glib::GList>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GResolverError {
    NotFound = 0,
    TemporaryFailure = 1,
    Internal = 2,
}
pub const G_RESOLVER_ERROR_NOT_FOUND: GResolverError = GResolverError::NotFound;
pub const G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = GResolverError::TemporaryFailure;
pub const G_RESOLVER_ERROR_INTERNAL: GResolverError = GResolverError::Internal;

#[repr(C)]
pub struct GResolverPrivate(gpointer);

#[repr(C)]
pub enum GResolverRecordType {
    Srv = 1,
    Mx = 2,
    Txt = 3,
    Soa = 4,
    Ns = 5,
}
pub const G_RESOLVER_RECORD_SRV: GResolverRecordType = GResolverRecordType::Srv;
pub const G_RESOLVER_RECORD_MX: GResolverRecordType = GResolverRecordType::Mx;
pub const G_RESOLVER_RECORD_TXT: GResolverRecordType = GResolverRecordType::Txt;
pub const G_RESOLVER_RECORD_SOA: GResolverRecordType = GResolverRecordType::Soa;
pub const G_RESOLVER_RECORD_NS: GResolverRecordType = GResolverRecordType::Ns;

pub enum GResource { }

#[repr(C)]
pub enum GResourceError {
    NotFound = 0,
    Internal = 1,
}
pub const G_RESOURCE_ERROR_NOT_FOUND: GResourceError = GResourceError::NotFound;
pub const G_RESOURCE_ERROR_INTERNAL: GResourceError = GResourceError::Internal;

#[repr(C)]
pub enum GResourceFlags {
    None = 0,
    Compressed = 1,
}
pub const G_RESOURCE_FLAGS_NONE: guint = 0;
pub const G_RESOURCE_FLAGS_COMPRESSED: guint = 1;

#[repr(C)]
pub enum GResourceLookupFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_RESOURCE_LOOKUP_FLAGS_NONE: guint = 0;

pub enum GSeekable { }

#[repr(C)]
pub struct GSeekableIface {
    pub g_iface: gobject::GTypeInterface,
    pub tell: Option<extern "C" fn (*mut GSeekable) -> i64>,
    pub can_seek: Option<extern "C" fn (*mut GSeekable) -> gboolean>,
    pub seek: Option<extern "C" fn (*mut GSeekable, i64, glib::GSeekType, *mut GCancellable) -> gboolean>,
    pub can_truncate: Option<extern "C" fn (*mut GSeekable) -> gboolean>,
    pub truncate_fn: Option<extern "C" fn (*mut GSeekable, i64, *mut GCancellable) -> gboolean>,
}

#[repr(C)]
pub struct GSettings {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSettingsPrivate,
}

#[repr(C)]
pub struct GSettingsBackend(gpointer);

#[repr(C)]
pub enum GSettingsBindFlags {
    Default = 0,
    Get = 1,
    Set = 2,
    NoSensitivity = 4,
    GetNoChanges = 8,
    InvertBoolean = 16,
}
pub const G_SETTINGS_BIND_DEFAULT: guint = 0;
pub const G_SETTINGS_BIND_GET: guint = 1;
pub const G_SETTINGS_BIND_SET: guint = 2;
pub const G_SETTINGS_BIND_NO_SENSITIVITY: guint = 4;
pub const G_SETTINGS_BIND_GET_NO_CHANGES: guint = 8;
pub const G_SETTINGS_BIND_INVERT_BOOLEAN: guint = 16;

pub type GSettingsBindGetMapping = extern "C" fn (*mut gobject::GValue, *mut glib::GVariant, gpointer) -> gboolean;

pub type GSettingsBindSetMapping = extern "C" fn (*const gobject::GValue, *const glib::GVariantType, gpointer) -> *mut glib::GVariant;

#[repr(C)]
pub struct GSettingsClass {
    pub parent_class: gobject::GObjectClass,
    pub writable_changed: Option<extern "C" fn (*mut GSettings, *const gchar)>,
    pub changed: Option<extern "C" fn (*mut GSettings, *const gchar)>,
    pub writable_change_event: Option<extern "C" fn (*mut GSettings, glib::GQuark) -> gboolean>,
    pub change_event: Option<extern "C" fn (*mut GSettings, *const glib::GQuark, gint) -> gboolean>,
    pub padding: [gpointer; 20],
}

pub type GSettingsGetMapping = extern "C" fn (*mut glib::GVariant, *mut gpointer, gpointer) -> gboolean;

#[repr(C)]
pub struct GSettingsPrivate(gpointer);

pub enum GSettingsSchema { }

pub enum GSettingsSchemaKey { }

pub enum GSettingsSchemaSource { }

pub enum GSimpleAction { }

#[repr(C)]
pub struct GSimpleActionGroup {
    parent_instance: gobject::GObject,
    priv_: *mut GSimpleActionGroupPrivate,
}

#[repr(C)]
pub struct GSimpleActionGroupClass {
    parent_class: gobject::GObjectClass,
    padding: [gpointer; 12],
}

#[repr(C)]
pub struct GSimpleActionGroupPrivate(gpointer);

pub enum GSimpleAsyncResult { }

#[repr(C)]
pub struct GSimpleAsyncResultClass(gpointer);

pub type GSimpleAsyncThreadFunc = extern "C" fn (*mut GSimpleAsyncResult, *mut gobject::GObject, *mut GCancellable);

pub enum GSimpleIOStream { }

pub enum GSimplePermission { }

#[repr(C)]
pub struct GSimpleProxyResolver {
    pub parent_instance: gobject::GObject,
    priv_: *mut GSimpleProxyResolverPrivate,
}

#[repr(C)]
pub struct GSimpleProxyResolverClass {
    pub parent_class: gobject::GObjectClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GSimpleProxyResolverPrivate(gpointer);

#[repr(C)]
pub struct GSocket {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketPrivate,
}

#[repr(C)]
pub struct GSocketAddress {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GSocketAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub get_family: Option<extern "C" fn (*mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size: Option<extern "C" fn (*mut GSocketAddress) -> gssize>,
    pub to_native: Option<extern "C" fn (*mut GSocketAddress, gpointer, gsize) -> gboolean>,
}

#[repr(C)]
pub struct GSocketAddressEnumerator {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GSocketAddressEnumeratorClass {
    pub parent_class: gobject::GObjectClass,
    pub next: Option<extern "C" fn (*mut GSocketAddressEnumerator, *mut GCancellable) -> *mut GSocketAddress>,
    pub next_async: Option<extern "C" fn (*mut GSocketAddressEnumerator, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub next_finish: Option<extern "C" fn (*mut GSocketAddressEnumerator, *mut GAsyncResult) -> *mut GSocketAddress>,
}

#[repr(C)]
pub struct GSocketClass {
    pub parent_class: gobject::GObjectClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
    pub _g_reserved7: Option<extern "C" fn ()>,
    pub _g_reserved8: Option<extern "C" fn ()>,
    pub _g_reserved9: Option<extern "C" fn ()>,
    pub _g_reserved10: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GSocketClient {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketClientPrivate,
}

#[repr(C)]
pub struct GSocketClientClass {
    pub parent_class: gobject::GObjectClass,
    pub event: Option<extern "C" fn (*mut GSocketClient, GSocketClientEvent, *mut GSocketConnectable, *mut GIOStream)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GSocketClientEvent {
    Resolving = 0,
    Resolved = 1,
    Connecting = 2,
    Connected = 3,
    ProxyNegotiating = 4,
    ProxyNegotiated = 5,
    TlsHandshaking = 6,
    TlsHandshaked = 7,
    Complete = 8,
}
pub const G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = GSocketClientEvent::Resolving;
pub const G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = GSocketClientEvent::Resolved;
pub const G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = GSocketClientEvent::Connecting;
pub const G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = GSocketClientEvent::Connected;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = GSocketClientEvent::ProxyNegotiating;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = GSocketClientEvent::ProxyNegotiated;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = GSocketClientEvent::TlsHandshaking;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = GSocketClientEvent::TlsHandshaked;
pub const G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = GSocketClientEvent::Complete;

#[repr(C)]
pub struct GSocketClientPrivate(gpointer);

pub enum GSocketConnectable { }

#[repr(C)]
pub struct GSocketConnectableIface {
    pub g_iface: gobject::GTypeInterface,
    pub enumerate: Option<extern "C" fn (*mut GSocketConnectable) -> *mut GSocketAddressEnumerator>,
    pub proxy_enumerate: Option<extern "C" fn (*mut GSocketConnectable) -> *mut GSocketAddressEnumerator>,
    pub to_string: Option<extern "C" fn (*mut GSocketConnectable) -> *mut gchar>,
}

#[repr(C)]
pub struct GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}

#[repr(C)]
pub struct GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GSocketConnectionPrivate(gpointer);

#[repr(C)]
pub struct GSocketControlMessage {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}

#[repr(C)]
pub struct GSocketControlMessageClass {
    pub parent_class: gobject::GObjectClass,
    pub get_size: Option<extern "C" fn (*mut GSocketControlMessage) -> gsize>,
    pub get_level: Option<extern "C" fn (*mut GSocketControlMessage) -> gint>,
    pub get_type: Option<extern "C" fn (*mut GSocketControlMessage) -> gint>,
    pub serialize: Option<extern "C" fn (*mut GSocketControlMessage, gpointer)>,
    pub deserialize: Option<extern "C" fn (gint, gint, gsize, gpointer) -> *mut GSocketControlMessage>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GSocketControlMessagePrivate(gpointer);

#[repr(C)]
pub struct GSocketListener {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GSocketListenerPrivate,
}

#[repr(C)]
pub struct GSocketListenerClass {
    pub parent_class: gobject::GObjectClass,
    pub changed: Option<extern "C" fn (*mut GSocketListener)>,
    pub event: Option<extern "C" fn (*mut GSocketListener, *mut GSocketListenerEvent, *mut GSocket)>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

#[repr(C)]
pub enum GSocketListenerEvent {
    Binding = 0,
    Bound = 1,
    Listening = 2,
    Listened = 3,
}
pub const G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = GSocketListenerEvent::Binding;
pub const G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = GSocketListenerEvent::Bound;
pub const G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = GSocketListenerEvent::Listening;
pub const G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = GSocketListenerEvent::Listened;

#[repr(C)]
pub struct GSocketListenerPrivate(gpointer);

#[repr(C)]
pub struct GSocketPrivate(gpointer);

#[repr(C)]
pub enum GSocketProtocol {
    Unknown = -1,
    Default = 0,
    Tcp = 6,
    Udp = 17,
    Sctp = 132,
}
pub const G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = GSocketProtocol::Unknown;
pub const G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = GSocketProtocol::Default;
pub const G_SOCKET_PROTOCOL_TCP: GSocketProtocol = GSocketProtocol::Tcp;
pub const G_SOCKET_PROTOCOL_UDP: GSocketProtocol = GSocketProtocol::Udp;
pub const G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = GSocketProtocol::Sctp;

#[repr(C)]
pub struct GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}

#[repr(C)]
pub struct GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: Option<extern "C" fn (*mut GSocketService, *mut GSocketConnection, *mut gobject::GObject) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GSocketServicePrivate(gpointer);

pub type GSocketSourceFunc = extern "C" fn (*mut GSocket, glib::GIOCondition, gpointer) -> gboolean;

#[repr(C)]
pub enum GSocketType {
    Invalid = 0,
    Stream = 1,
    Datagram = 2,
    Seqpacket = 3,
}
pub const G_SOCKET_TYPE_INVALID: GSocketType = GSocketType::Invalid;
pub const G_SOCKET_TYPE_STREAM: GSocketType = GSocketType::Stream;
pub const G_SOCKET_TYPE_DATAGRAM: GSocketType = GSocketType::Datagram;
pub const G_SOCKET_TYPE_SEQPACKET: GSocketType = GSocketType::Seqpacket;

pub enum GSrvTarget { }

#[repr(C)]
pub struct GStaticResource {
    data: u8,
    data_len: gsize,
    resource: *mut GResource,
    next: *mut GStaticResource,
    padding: gpointer,
}

pub enum GSubprocess { }

#[repr(C)]
pub enum GSubprocessFlags {
    None = 0,
    StdinPipe = 1,
    StdinInherit = 2,
    StdoutPipe = 4,
    StdoutSilence = 8,
    StderrPipe = 16,
    StderrSilence = 32,
    StderrMerge = 64,
    InheritFds = 128,
}
pub const G_SUBPROCESS_FLAGS_NONE: guint = 0;
pub const G_SUBPROCESS_FLAGS_STDIN_PIPE: guint = 1;
pub const G_SUBPROCESS_FLAGS_STDIN_INHERIT: guint = 2;
pub const G_SUBPROCESS_FLAGS_STDOUT_PIPE: guint = 4;
pub const G_SUBPROCESS_FLAGS_STDOUT_SILENCE: guint = 8;
pub const G_SUBPROCESS_FLAGS_STDERR_PIPE: guint = 16;
pub const G_SUBPROCESS_FLAGS_STDERR_SILENCE: guint = 32;
pub const G_SUBPROCESS_FLAGS_STDERR_MERGE: guint = 64;
pub const G_SUBPROCESS_FLAGS_INHERIT_FDS: guint = 128;

pub enum GSubprocessLauncher { }

pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &'static [u8] = b"gio-tls-backend\0";

pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &'static [u8] = b"1.3.6.1.5.5.7.3.2\0";

pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &'static [u8] = b"1.3.6.1.5.5.7.3.1\0";

pub enum GTask { }

#[repr(C)]
pub struct GTaskClass(gpointer);

pub type GTaskThreadFunc = extern "C" fn (*mut GTask, gpointer, gpointer, *mut GCancellable);

#[repr(C)]
pub struct GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}

#[repr(C)]
pub struct GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}

#[repr(C)]
pub struct GTcpConnectionPrivate(gpointer);

#[repr(C)]
pub struct GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}

#[repr(C)]
pub struct GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}

#[repr(C)]
pub struct GTcpWrapperConnectionPrivate(gpointer);

pub enum GTestDBus { }

#[repr(C)]
pub enum GTestDBusFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_TEST_DBUS_NONE: guint = 0;

pub enum GThemedIcon { }

#[repr(C)]
pub struct GThemedIconClass(gpointer);

#[repr(C)]
pub struct GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}

#[repr(C)]
pub struct GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: Option<extern "C" fn (*mut GThreadedSocketService, *mut GSocketConnection, *mut gobject::GObject) -> gboolean>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
}

#[repr(C)]
pub struct GThreadedSocketServicePrivate(gpointer);

#[repr(C)]
pub enum GTlsAuthenticationMode {
    None = 0,
    Requested = 1,
    Required = 2,
}
pub const G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = GTlsAuthenticationMode::None;
pub const G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = GTlsAuthenticationMode::Requested;
pub const G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = GTlsAuthenticationMode::Required;

pub enum GTlsBackend { }

#[repr(C)]
pub struct GTlsBackendInterface {
    pub g_iface: gobject::GTypeInterface,
    pub supports_tls: Option<extern "C" fn (*mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: Option<extern "C" fn () -> GType>,
    pub get_client_connection_type: Option<extern "C" fn () -> GType>,
    pub get_server_connection_type: Option<extern "C" fn () -> GType>,
    pub get_file_database_type: Option<extern "C" fn () -> GType>,
    pub get_default_database: Option<extern "C" fn (*mut GTlsBackend) -> *mut GTlsDatabase>,
}

#[repr(C)]
pub struct GTlsCertificate {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}

#[repr(C)]
pub struct GTlsCertificateClass {
    pub parent_class: gobject::GObjectClass,
    pub verify: Option<extern "C" fn (*mut GTlsCertificate, *mut GSocketConnectable, *mut GTlsCertificate) -> GTlsCertificateFlags>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub enum GTlsCertificateFlags {
    UnknownCa = 1,
    BadIdentity = 2,
    NotActivated = 4,
    Expired = 8,
    Revoked = 16,
    Insecure = 32,
    GenericError = 64,
    ValidateAll = 127,
}
pub const G_TLS_CERTIFICATE_UNKNOWN_CA: guint = 1;
pub const G_TLS_CERTIFICATE_BAD_IDENTITY: guint = 2;
pub const G_TLS_CERTIFICATE_NOT_ACTIVATED: guint = 4;
pub const G_TLS_CERTIFICATE_EXPIRED: guint = 8;
pub const G_TLS_CERTIFICATE_REVOKED: guint = 16;
pub const G_TLS_CERTIFICATE_INSECURE: guint = 32;
pub const G_TLS_CERTIFICATE_GENERIC_ERROR: guint = 64;
pub const G_TLS_CERTIFICATE_VALIDATE_ALL: guint = 127;

#[repr(C)]
pub struct GTlsCertificatePrivate(gpointer);

#[repr(C)]
pub enum GTlsCertificateRequestFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_TLS_CERTIFICATE_REQUEST_NONE: GTlsCertificateRequestFlags = GTlsCertificateRequestFlags::None;

pub enum GTlsClientConnection { }

#[repr(C)]
pub struct GTlsClientConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
    pub copy_session_state: Option<extern "C" fn (*mut GTlsClientConnection, *mut GTlsClientConnection)>,
}

#[repr(C)]
pub struct GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}

#[repr(C)]
pub struct GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: Option<extern "C" fn (*mut GTlsConnection, *mut GTlsCertificate, GTlsCertificateFlags) -> gboolean>,
    pub handshake: Option<extern "C" fn (*mut GTlsConnection, *mut GCancellable) -> gboolean>,
    pub handshake_async: Option<extern "C" fn (*mut GTlsConnection, gint, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub handshake_finish: Option<extern "C" fn (*mut GTlsConnection, *mut GAsyncResult) -> gboolean>,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GTlsConnectionPrivate(gpointer);

#[repr(C)]
pub struct GTlsDatabase {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}

#[repr(C)]
pub struct GTlsDatabaseClass {
    pub parent_class: gobject::GObjectClass,
    pub verify_chain: Option<extern "C" fn (*mut GTlsDatabase, *mut GTlsCertificate, *const gchar, *mut GSocketConnectable, *mut GTlsInteraction, GTlsDatabaseVerifyFlags, *mut GCancellable) -> GTlsCertificateFlags>,
    pub verify_chain_async: Option<extern "C" fn (*mut GTlsDatabase, *mut GTlsCertificate, *const gchar, *mut GSocketConnectable, *mut GTlsInteraction, GTlsDatabaseVerifyFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub verify_chain_finish: Option<extern "C" fn (*mut GTlsDatabase, *mut GAsyncResult) -> GTlsCertificateFlags>,
    pub create_certificate_handle: Option<extern "C" fn (*mut GTlsDatabase, *mut GTlsCertificate) -> *mut gchar>,
    pub lookup_certificate_for_handle: Option<extern "C" fn (*mut GTlsDatabase, *const gchar, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable) -> *mut GTlsCertificate>,
    pub lookup_certificate_for_handle_async: Option<extern "C" fn (*mut GTlsDatabase, *const gchar, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_certificate_for_handle_finish: Option<extern "C" fn (*mut GTlsDatabase, *mut GAsyncResult) -> *mut GTlsCertificate>,
    pub lookup_certificate_issuer: Option<extern "C" fn (*mut GTlsDatabase, *mut GTlsCertificate, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable) -> *mut GTlsCertificate>,
    pub lookup_certificate_issuer_async: Option<extern "C" fn (*mut GTlsDatabase, *mut GTlsCertificate, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_certificate_issuer_finish: Option<extern "C" fn (*mut GTlsDatabase, *mut GAsyncResult) -> *mut GTlsCertificate>,
    pub lookup_certificates_issued_by: Option<extern "C" fn (*mut GTlsDatabase, *mut glib::GByteArray, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable) -> *mut glib::GList>,
    pub lookup_certificates_issued_by_async: Option<extern "C" fn (*mut GTlsDatabase, *mut glib::GByteArray, *mut GTlsInteraction, GTlsDatabaseLookupFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub lookup_certificates_issued_by_finish: Option<extern "C" fn (*mut GTlsDatabase, *mut GAsyncResult) -> *mut glib::GList>,
    padding: [gpointer; 16],
}

#[repr(C)]
pub enum GTlsDatabaseLookupFlags {
    None = 0,
    Keypair = 1,
}
pub const G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = GTlsDatabaseLookupFlags::None;
pub const G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = GTlsDatabaseLookupFlags::Keypair;

#[repr(C)]
pub struct GTlsDatabasePrivate(gpointer);

#[repr(C)]
pub enum GTlsDatabaseVerifyFlags {
    None = 0,
    _Dummy = 1,
}
pub const G_TLS_DATABASE_VERIFY_NONE: guint = 0;

#[repr(C)]
pub enum GTlsError {
    Unavailable = 0,
    Misc = 1,
    BadCertificate = 2,
    NotTls = 3,
    Handshake = 4,
    CertificateRequired = 5,
    Eof = 6,
}
pub const G_TLS_ERROR_UNAVAILABLE: GTlsError = GTlsError::Unavailable;
pub const G_TLS_ERROR_MISC: GTlsError = GTlsError::Misc;
pub const G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = GTlsError::BadCertificate;
pub const G_TLS_ERROR_NOT_TLS: GTlsError = GTlsError::NotTls;
pub const G_TLS_ERROR_HANDSHAKE: GTlsError = GTlsError::Handshake;
pub const G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = GTlsError::CertificateRequired;
pub const G_TLS_ERROR_EOF: GTlsError = GTlsError::Eof;

pub enum GTlsFileDatabase { }

#[repr(C)]
pub struct GTlsFileDatabaseInterface {
    pub g_iface: gobject::GTypeInterface,
    padding: [gpointer; 8],
}

#[repr(C)]
pub struct GTlsInteraction {
    parent_instance: gobject::GObject,
    priv_: *mut GTlsInteractionPrivate,
}

#[repr(C)]
pub struct GTlsInteractionClass {
    parent_class: gobject::GObjectClass,
    pub ask_password: Option<extern "C" fn (*mut GTlsInteraction, *mut GTlsPassword, *mut GCancellable) -> GTlsInteractionResult>,
    pub ask_password_async: Option<extern "C" fn (*mut GTlsInteraction, *mut GTlsPassword, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub ask_password_finish: Option<extern "C" fn (*mut GTlsInteraction, *mut GAsyncResult) -> GTlsInteractionResult>,
    pub request_certificate: Option<extern "C" fn (*mut GTlsInteraction, *mut GTlsConnection, GTlsCertificateRequestFlags, *mut GCancellable) -> GTlsInteractionResult>,
    pub request_certificate_async: Option<extern "C" fn (*mut GTlsInteraction, *mut GTlsConnection, GTlsCertificateRequestFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub request_certificate_finish: Option<extern "C" fn (*mut GTlsInteraction, *mut GAsyncResult) -> GTlsInteractionResult>,
    padding: [gpointer; 21],
}

#[repr(C)]
pub struct GTlsInteractionPrivate(gpointer);

#[repr(C)]
pub enum GTlsInteractionResult {
    Unhandled = 0,
    Handled = 1,
    Failed = 2,
}
pub const G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = GTlsInteractionResult::Unhandled;
pub const G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = GTlsInteractionResult::Handled;
pub const G_TLS_INTERACTION_FAILED: GTlsInteractionResult = GTlsInteractionResult::Failed;

#[repr(C)]
pub struct GTlsPassword {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}

#[repr(C)]
pub struct GTlsPasswordClass {
    pub parent_class: gobject::GObjectClass,
    pub get_value: Option<extern "C" fn (*mut GTlsPassword, gsize) -> u8>,
    pub set_value: Option<extern "C" fn (*mut GTlsPassword, u8, gssize, Option<glib::GDestroyNotify>)>,
    pub get_default_warning: Option<extern "C" fn (*mut GTlsPassword) -> *const gchar>,
    padding: [gpointer; 4],
}

#[repr(C)]
pub enum GTlsPasswordFlags {
    None = 0,
    Retry = 2,
    ManyTries = 4,
    FinalTry = 8,
}
pub const G_TLS_PASSWORD_NONE: guint = 0;
pub const G_TLS_PASSWORD_RETRY: guint = 2;
pub const G_TLS_PASSWORD_MANY_TRIES: guint = 4;
pub const G_TLS_PASSWORD_FINAL_TRY: guint = 8;

#[repr(C)]
pub struct GTlsPasswordPrivate(gpointer);

#[repr(C)]
pub enum GTlsRehandshakeMode {
    Never = 0,
    Safely = 1,
    Unsafely = 2,
}
pub const G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = GTlsRehandshakeMode::Never;
pub const G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = GTlsRehandshakeMode::Safely;
pub const G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = GTlsRehandshakeMode::Unsafely;

pub enum GTlsServerConnection { }

#[repr(C)]
pub struct GTlsServerConnectionInterface {
    pub g_iface: gobject::GTypeInterface,
}

pub const G_VFS_EXTENSION_POINT_NAME: &'static [u8] = b"gio-vfs\0";

pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &'static [u8] = b"class\0";

pub const G_VOLUME_IDENTIFIER_KIND_HAL_UDI: &'static [u8] = b"hal-udi\0";

pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &'static [u8] = b"label\0";

pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &'static [u8] = b"nfs-mount\0";

pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &'static [u8] = b"unix-device\0";

pub const G_VOLUME_IDENTIFIER_KIND_UUID: &'static [u8] = b"uuid\0";

pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static [u8] = b"gio-volume-monitor\0";

#[repr(C)]
pub struct GVfs {
    pub parent_instance: gobject::GObject,
}

#[repr(C)]
pub struct GVfsClass {
    pub parent_class: gobject::GObjectClass,
    pub is_active: Option<extern "C" fn (*mut GVfs) -> gboolean>,
    pub get_file_for_path: Option<extern "C" fn (*mut GVfs, *const gchar) -> *mut GFile>,
    pub get_file_for_uri: Option<extern "C" fn (*mut GVfs, *const gchar) -> *mut GFile>,
    pub get_supported_uri_schemes: Option<extern "C" fn (*mut GVfs) -> *const *const gchar>,
    pub parse_name: Option<extern "C" fn (*mut GVfs, *const gchar) -> *mut GFile>,
    pub local_file_add_info: Option<extern "C" fn (*mut GVfs, *const gchar, u64, *mut GFileAttributeMatcher, *mut GFileInfo, *mut GCancellable, gpointer, *mut glib::GDestroyNotify)>,
    pub add_writable_namespaces: Option<extern "C" fn (*mut GVfs, *mut GFileAttributeInfoList)>,
    pub local_file_set_attributes: Option<extern "C" fn (*mut GVfs, *const gchar, *mut GFileInfo, GFileQueryInfoFlags, *mut GCancellable) -> gboolean>,
    pub local_file_removed: Option<extern "C" fn (*mut GVfs, *const gchar)>,
    pub local_file_moved: Option<extern "C" fn (*mut GVfs, *const gchar, *const gchar)>,
    pub deserialize_icon: Option<extern "C" fn (*mut GVfs, *mut glib::GVariant) -> *mut GIcon>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

pub enum GVolume { }

#[repr(C)]
pub struct GVolumeIface {
    pub g_iface: gobject::GTypeInterface,
    pub changed: Option<extern "C" fn (*mut GVolume)>,
    pub removed: Option<extern "C" fn (*mut GVolume)>,
    pub get_name: Option<extern "C" fn (*mut GVolume) -> *mut gchar>,
    pub get_icon: Option<extern "C" fn (*mut GVolume) -> *mut GIcon>,
    pub get_uuid: Option<extern "C" fn (*mut GVolume) -> *mut gchar>,
    pub get_drive: Option<extern "C" fn (*mut GVolume) -> *mut GDrive>,
    pub get_mount: Option<extern "C" fn (*mut GVolume) -> *mut GMount>,
    pub can_mount: Option<extern "C" fn (*mut GVolume) -> gboolean>,
    pub can_eject: Option<extern "C" fn (*mut GVolume) -> gboolean>,
    pub mount_fn: Option<extern "C" fn (*mut GVolume, GMountMountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub mount_finish: Option<extern "C" fn (*mut GVolume, *mut GAsyncResult) -> gboolean>,
    pub eject: Option<extern "C" fn (*mut GVolume, GMountUnmountFlags, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_finish: Option<extern "C" fn (*mut GVolume, *mut GAsyncResult) -> gboolean>,
    pub get_identifier: Option<extern "C" fn (*mut GVolume, *const gchar) -> *mut gchar>,
    pub enumerate_identifiers: Option<extern "C" fn (*mut GVolume) -> *mut *mut gchar>,
    pub should_automount: Option<extern "C" fn (*mut GVolume) -> gboolean>,
    pub get_activation_root: Option<extern "C" fn (*mut GVolume) -> *mut GFile>,
    pub eject_with_operation: Option<extern "C" fn (*mut GVolume, GMountUnmountFlags, *mut GMountOperation, *mut GCancellable, Option<GAsyncReadyCallback>, gpointer)>,
    pub eject_with_operation_finish: Option<extern "C" fn (*mut GVolume, *mut GAsyncResult) -> gboolean>,
    pub get_sort_key: Option<extern "C" fn (*mut GVolume) -> *const gchar>,
    pub get_symbolic_icon: Option<extern "C" fn (*mut GVolume) -> *mut GIcon>,
}

#[repr(C)]
pub struct GVolumeMonitor {
    pub parent_instance: gobject::GObject,
    priv_: gpointer,
}

#[repr(C)]
pub struct GVolumeMonitorClass {
    pub parent_class: gobject::GObjectClass,
    pub volume_added: Option<extern "C" fn (*mut GVolumeMonitor, *mut GVolume)>,
    pub volume_removed: Option<extern "C" fn (*mut GVolumeMonitor, *mut GVolume)>,
    pub volume_changed: Option<extern "C" fn (*mut GVolumeMonitor, *mut GVolume)>,
    pub mount_added: Option<extern "C" fn (*mut GVolumeMonitor, *mut GMount)>,
    pub mount_removed: Option<extern "C" fn (*mut GVolumeMonitor, *mut GMount)>,
    pub mount_pre_unmount: Option<extern "C" fn (*mut GVolumeMonitor, *mut GMount)>,
    pub mount_changed: Option<extern "C" fn (*mut GVolumeMonitor, *mut GMount)>,
    pub drive_connected: Option<extern "C" fn (*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_disconnected: Option<extern "C" fn (*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_changed: Option<extern "C" fn (*mut GVolumeMonitor, *mut GDrive)>,
    pub is_supported: Option<extern "C" fn () -> gboolean>,
    pub get_connected_drives: Option<extern "C" fn (*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_volumes: Option<extern "C" fn (*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_mounts: Option<extern "C" fn (*mut GVolumeMonitor) -> *mut glib::GList>,
    pub get_volume_for_uuid: Option<extern "C" fn (*mut GVolumeMonitor, *const gchar) -> *mut GVolume>,
    pub get_mount_for_uuid: Option<extern "C" fn (*mut GVolumeMonitor, *const gchar) -> *mut GMount>,
    pub adopt_orphan_mount: Option<extern "C" fn (*mut GMount, *mut GVolumeMonitor) -> *mut GVolume>,
    pub drive_eject_button: Option<extern "C" fn (*mut GVolumeMonitor, *mut GDrive)>,
    pub drive_stop_button: Option<extern "C" fn (*mut GVolumeMonitor, *mut GDrive)>,
    pub _g_reserved1: Option<extern "C" fn ()>,
    pub _g_reserved2: Option<extern "C" fn ()>,
    pub _g_reserved3: Option<extern "C" fn ()>,
    pub _g_reserved4: Option<extern "C" fn ()>,
    pub _g_reserved5: Option<extern "C" fn ()>,
    pub _g_reserved6: Option<extern "C" fn ()>,
}

pub enum GZlibCompressor { }

#[repr(C)]
pub struct GZlibCompressorClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub enum GZlibCompressorFormat {
    Zlib = 0,
    Gzip = 1,
    Raw = 2,
}
pub const G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = GZlibCompressorFormat::Zlib;
pub const G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = GZlibCompressorFormat::Gzip;
pub const G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = GZlibCompressorFormat::Raw;

pub enum GZlibDecompressor { }

#[repr(C)]
pub struct GZlibDecompressorClass {
    pub parent_class: gobject::GObjectClass,
}

// GType functions
extern {
    pub fn g_action_get_type() -> GType;
    pub fn g_action_group_get_type() -> GType;
    pub fn g_action_map_get_type() -> GType;
    pub fn g_app_info_create_flags_get_type() -> GType;
    pub fn g_app_info_get_type() -> GType;
    pub fn g_app_info_monitor_get_type() -> GType;
    pub fn g_app_launch_context_get_type() -> GType;
    pub fn g_application_command_line_get_type() -> GType;
    pub fn g_application_flags_get_type() -> GType;
    pub fn g_application_get_type() -> GType;
    pub fn g_ask_password_flags_get_type() -> GType;
    pub fn g_async_initable_get_type() -> GType;
    pub fn g_async_result_get_type() -> GType;
    pub fn g_buffered_input_stream_get_type() -> GType;
    pub fn g_buffered_output_stream_get_type() -> GType;
    pub fn g_bus_name_owner_flags_get_type() -> GType;
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
    pub fn g_bus_type_get_type() -> GType;
    pub fn g_bytes_icon_get_type() -> GType;
    pub fn g_cancellable_get_type() -> GType;
    pub fn g_charset_converter_get_type() -> GType;
    pub fn g_converter_flags_get_type() -> GType;
    pub fn g_converter_get_type() -> GType;
    pub fn g_converter_input_stream_get_type() -> GType;
    pub fn g_converter_output_stream_get_type() -> GType;
    pub fn g_converter_result_get_type() -> GType;
    pub fn g_credentials_get_type() -> GType;
    pub fn g_credentials_type_get_type() -> GType;
    pub fn g_data_input_stream_get_type() -> GType;
    pub fn g_data_output_stream_get_type() -> GType;
    pub fn g_data_stream_byte_order_get_type() -> GType;
    pub fn g_data_stream_newline_type_get_type() -> GType;
    pub fn g_datagram_based_get_type() -> GType;
    pub fn g_dbus_action_group_get_type() -> GType;
    pub fn g_dbus_annotation_info_get_type() -> GType;
    pub fn g_dbus_arg_info_get_type() -> GType;
    pub fn g_dbus_auth_observer_get_type() -> GType;
    pub fn g_dbus_call_flags_get_type() -> GType;
    pub fn g_dbus_capability_flags_get_type() -> GType;
    pub fn g_dbus_connection_flags_get_type() -> GType;
    pub fn g_dbus_connection_get_type() -> GType;
    pub fn g_dbus_error_get_type() -> GType;
    pub fn g_dbus_interface_get_type() -> GType;
    pub fn g_dbus_interface_info_get_type() -> GType;
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
    pub fn g_dbus_menu_model_get_type() -> GType;
    pub fn g_dbus_message_byte_order_get_type() -> GType;
    pub fn g_dbus_message_flags_get_type() -> GType;
    pub fn g_dbus_message_get_type() -> GType;
    pub fn g_dbus_message_header_field_get_type() -> GType;
    pub fn g_dbus_message_type_get_type() -> GType;
    pub fn g_dbus_method_info_get_type() -> GType;
    pub fn g_dbus_method_invocation_get_type() -> GType;
    pub fn g_dbus_node_info_get_type() -> GType;
    pub fn g_dbus_object_get_type() -> GType;
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
    pub fn g_dbus_object_manager_client_get_type() -> GType;
    pub fn g_dbus_object_manager_get_type() -> GType;
    pub fn g_dbus_object_manager_server_get_type() -> GType;
    pub fn g_dbus_object_proxy_get_type() -> GType;
    pub fn g_dbus_object_skeleton_get_type() -> GType;
    pub fn g_dbus_property_info_flags_get_type() -> GType;
    pub fn g_dbus_property_info_get_type() -> GType;
    pub fn g_dbus_proxy_flags_get_type() -> GType;
    pub fn g_dbus_proxy_get_type() -> GType;
    pub fn g_dbus_send_message_flags_get_type() -> GType;
    pub fn g_dbus_server_flags_get_type() -> GType;
    pub fn g_dbus_server_get_type() -> GType;
    pub fn g_dbus_signal_flags_get_type() -> GType;
    pub fn g_dbus_signal_info_get_type() -> GType;
    pub fn g_dbus_subtree_flags_get_type() -> GType;
    pub fn g_drive_get_type() -> GType;
    pub fn g_drive_start_flags_get_type() -> GType;
    pub fn g_drive_start_stop_type_get_type() -> GType;
    pub fn g_emblem_get_type() -> GType;
    pub fn g_emblem_origin_get_type() -> GType;
    pub fn g_emblemed_icon_get_type() -> GType;
    pub fn g_file_attribute_info_flags_get_type() -> GType;
    pub fn g_file_attribute_info_list_get_type() -> GType;
    pub fn g_file_attribute_matcher_get_type() -> GType;
    pub fn g_file_attribute_status_get_type() -> GType;
    pub fn g_file_attribute_type_get_type() -> GType;
    pub fn g_file_copy_flags_get_type() -> GType;
    pub fn g_file_create_flags_get_type() -> GType;
    pub fn g_file_enumerator_get_type() -> GType;
    pub fn g_file_get_type() -> GType;
    pub fn g_file_icon_get_type() -> GType;
    pub fn g_file_info_get_type() -> GType;
    pub fn g_file_input_stream_get_type() -> GType;
    pub fn g_file_io_stream_get_type() -> GType;
    pub fn g_file_measure_flags_get_type() -> GType;
    pub fn g_file_monitor_event_get_type() -> GType;
    pub fn g_file_monitor_flags_get_type() -> GType;
    pub fn g_file_monitor_get_type() -> GType;
    pub fn g_file_output_stream_get_type() -> GType;
    pub fn g_file_query_info_flags_get_type() -> GType;
    pub fn g_file_type_get_type() -> GType;
    pub fn g_filename_completer_get_type() -> GType;
    pub fn g_filesystem_preview_type_get_type() -> GType;
    pub fn g_filter_input_stream_get_type() -> GType;
    pub fn g_filter_output_stream_get_type() -> GType;
    pub fn g_icon_get_type() -> GType;
    pub fn g_inet_address_get_type() -> GType;
    pub fn g_inet_address_mask_get_type() -> GType;
    pub fn g_inet_socket_address_get_type() -> GType;
    pub fn g_initable_get_type() -> GType;
    pub fn g_input_stream_get_type() -> GType;
    pub fn g_io_error_enum_get_type() -> GType;
    pub fn g_io_module_get_type() -> GType;
    pub fn g_io_module_scope_flags_get_type() -> GType;
    pub fn g_io_stream_get_type() -> GType;
    pub fn g_io_stream_splice_flags_get_type() -> GType;
    pub fn g_list_model_get_type() -> GType;
    pub fn g_list_store_get_type() -> GType;
    pub fn g_loadable_icon_get_type() -> GType;
    pub fn g_memory_input_stream_get_type() -> GType;
    pub fn g_memory_output_stream_get_type() -> GType;
    pub fn g_menu_attribute_iter_get_type() -> GType;
    pub fn g_menu_get_type() -> GType;
    pub fn g_menu_item_get_type() -> GType;
    pub fn g_menu_link_iter_get_type() -> GType;
    pub fn g_menu_model_get_type() -> GType;
    pub fn g_mount_get_type() -> GType;
    pub fn g_mount_mount_flags_get_type() -> GType;
    pub fn g_mount_operation_get_type() -> GType;
    pub fn g_mount_operation_result_get_type() -> GType;
    pub fn g_mount_unmount_flags_get_type() -> GType;
    pub fn g_native_volume_monitor_get_type() -> GType;
    pub fn g_network_address_get_type() -> GType;
    pub fn g_network_connectivity_get_type() -> GType;
    pub fn g_network_monitor_get_type() -> GType;
    pub fn g_network_service_get_type() -> GType;
    pub fn g_notification_get_type() -> GType;
    pub fn g_notification_priority_get_type() -> GType;
    pub fn g_output_stream_get_type() -> GType;
    pub fn g_output_stream_splice_flags_get_type() -> GType;
    pub fn g_password_save_get_type() -> GType;
    pub fn g_permission_get_type() -> GType;
    pub fn g_pollable_input_stream_get_type() -> GType;
    pub fn g_pollable_output_stream_get_type() -> GType;
    pub fn g_property_action_get_type() -> GType;
    pub fn g_proxy_address_enumerator_get_type() -> GType;
    pub fn g_proxy_address_get_type() -> GType;
    pub fn g_proxy_get_type() -> GType;
    pub fn g_proxy_resolver_get_type() -> GType;
    pub fn g_remote_action_group_get_type() -> GType;
    pub fn g_resolver_error_get_type() -> GType;
    pub fn g_resolver_get_type() -> GType;
    pub fn g_resolver_record_type_get_type() -> GType;
    pub fn g_resource_error_get_type() -> GType;
    pub fn g_resource_flags_get_type() -> GType;
    pub fn g_resource_get_type() -> GType;
    pub fn g_resource_lookup_flags_get_type() -> GType;
    pub fn g_seekable_get_type() -> GType;
    pub fn g_settings_bind_flags_get_type() -> GType;
    pub fn g_settings_get_type() -> GType;
    pub fn g_settings_schema_get_type() -> GType;
    pub fn g_settings_schema_key_get_type() -> GType;
    pub fn g_settings_schema_source_get_type() -> GType;
    pub fn g_simple_action_get_type() -> GType;
    pub fn g_simple_action_group_get_type() -> GType;
    pub fn g_simple_async_result_get_type() -> GType;
    pub fn g_simple_io_stream_get_type() -> GType;
    pub fn g_simple_permission_get_type() -> GType;
    pub fn g_simple_proxy_resolver_get_type() -> GType;
    pub fn g_socket_address_enumerator_get_type() -> GType;
    pub fn g_socket_address_get_type() -> GType;
    pub fn g_socket_client_event_get_type() -> GType;
    pub fn g_socket_client_get_type() -> GType;
    pub fn g_socket_connectable_get_type() -> GType;
    pub fn g_socket_connection_get_type() -> GType;
    pub fn g_socket_control_message_get_type() -> GType;
    pub fn g_socket_family_get_type() -> GType;
    pub fn g_socket_get_type() -> GType;
    pub fn g_socket_listener_event_get_type() -> GType;
    pub fn g_socket_listener_get_type() -> GType;
    pub fn g_socket_msg_flags_get_type() -> GType;
    pub fn g_socket_protocol_get_type() -> GType;
    pub fn g_socket_service_get_type() -> GType;
    pub fn g_socket_type_get_type() -> GType;
    pub fn g_srv_target_get_type() -> GType;
    pub fn g_subprocess_flags_get_type() -> GType;
    pub fn g_subprocess_get_type() -> GType;
    pub fn g_subprocess_launcher_get_type() -> GType;
    pub fn g_task_get_type() -> GType;
    pub fn g_tcp_connection_get_type() -> GType;
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
    pub fn g_test_dbus_flags_get_type() -> GType;
    pub fn g_test_dbus_get_type() -> GType;
    pub fn g_themed_icon_get_type() -> GType;
    pub fn g_threaded_socket_service_get_type() -> GType;
    pub fn g_tls_authentication_mode_get_type() -> GType;
    pub fn g_tls_backend_get_type() -> GType;
    pub fn g_tls_certificate_flags_get_type() -> GType;
    pub fn g_tls_certificate_get_type() -> GType;
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
    pub fn g_tls_client_connection_get_type() -> GType;
    pub fn g_tls_connection_get_type() -> GType;
    pub fn g_tls_database_get_type() -> GType;
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
    pub fn g_tls_database_verify_flags_get_type() -> GType;
    pub fn g_tls_error_get_type() -> GType;
    pub fn g_tls_file_database_get_type() -> GType;
    pub fn g_tls_interaction_get_type() -> GType;
    pub fn g_tls_interaction_result_get_type() -> GType;
    pub fn g_tls_password_flags_get_type() -> GType;
    pub fn g_tls_password_get_type() -> GType;
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
    pub fn g_tls_server_connection_get_type() -> GType;
    pub fn g_vfs_get_type() -> GType;
    pub fn g_volume_get_type() -> GType;
    pub fn g_volume_monitor_get_type() -> GType;
    pub fn g_zlib_compressor_format_get_type() -> GType;
    pub fn g_zlib_compressor_get_type() -> GType;
    pub fn g_zlib_decompressor_get_type() -> GType;
}

extern {
    pub fn g_action_activate(action: *mut GAction, parameter: *mut glib::GVariant);
    pub fn g_action_change_state(action: *mut GAction, value: *mut glib::GVariant);
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const glib::GVariantType;
    pub fn g_action_get_state(action: *mut GAction) -> *mut glib::GVariant;
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut glib::GVariant;
    pub fn g_action_get_state_type(action: *mut GAction) -> *const glib::GVariantType;
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const gchar);
    pub fn g_action_group_action_enabled_changed(action_group: *mut GActionGroup, action_name: *const gchar, enabled: gboolean);
    pub fn g_action_group_action_removed(action_group: *mut GActionGroup, action_name: *const gchar);
    pub fn g_action_group_action_state_changed(action_group: *mut GActionGroup, action_name: *const gchar, state: *mut glib::GVariant);
    pub fn g_action_group_activate_action(action_group: *mut GActionGroup, action_name: *const gchar, parameter: *mut glib::GVariant);
    pub fn g_action_group_change_action_state(action_group: *mut GActionGroup, action_name: *const gchar, value: *mut glib::GVariant);
    pub fn g_action_group_get_action_enabled(action_group: *mut GActionGroup, action_name: *const gchar) -> gboolean;
    pub fn g_action_group_get_action_parameter_type(action_group: *mut GActionGroup, action_name: *const gchar) -> *const glib::GVariantType;
    pub fn g_action_group_get_action_state(action_group: *mut GActionGroup, action_name: *const gchar) -> *mut glib::GVariant;
    pub fn g_action_group_get_action_state_hint(action_group: *mut GActionGroup, action_name: *const gchar) -> *mut glib::GVariant;
    pub fn g_action_group_get_action_state_type(action_group: *mut GActionGroup, action_name: *const gchar) -> *const glib::GVariantType;
    pub fn g_action_group_has_action(action_group: *mut GActionGroup, action_name: *const gchar) -> gboolean;
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut gchar;
    pub fn g_action_group_query_action(action_group: *mut GActionGroup, action_name: *const gchar, enabled: *mut gboolean, parameter_type: *mut *const glib::GVariantType, state_type: *mut *const glib::GVariantType, state_hint: *mut *mut glib::GVariant, state: *mut *mut glib::GVariant) -> gboolean;
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
    pub fn g_action_map_add_action_entries(action_map: *mut GActionMap, entries: *mut GActionEntry, n_entries: gint, user_data: gpointer);
    pub fn g_action_map_lookup_action(action_map: *mut GActionMap, action_name: *const gchar) -> *mut GAction;
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const gchar);
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
    pub fn g_action_parse_detailed_name(detailed_name: *const gchar, action_name: *mut *mut gchar, target_value: *mut *mut glib::GVariant) -> gboolean;
    pub fn g_action_print_detailed_name(action_name: *const gchar, target_value: *mut glib::GVariant) -> *mut gchar;
    pub fn g_app_info_add_supports_type(appinfo: *mut GAppInfo, content_type: *const gchar) -> gboolean;
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_create_from_commandline(commandline: *const gchar, application_name: *const gchar, flags: GAppInfoCreateFlags) -> *mut GAppInfo;
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_get_all() -> *mut glib::GList;
    pub fn g_app_info_get_all_for_type(content_type: *const gchar) -> *mut glib::GList;
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_default_for_type(content_type: *const gchar, must_support_uris: gboolean) -> *mut GAppInfo;
    pub fn g_app_info_get_default_for_uri_scheme(uri_scheme: *const gchar) -> *mut GAppInfo;
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar) -> *mut glib::GList;
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const gchar;
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar) -> *mut glib::GList;
    pub fn g_app_info_get_supported_types(appinfo: *mut GAppInfo) -> *mut *mut gchar;
    pub fn g_app_info_launch(appinfo: *mut GAppInfo, files: *mut glib::GList, launch_context: *mut GAppLaunchContext) -> gboolean;
    pub fn g_app_info_launch_default_for_uri(uri: *const gchar, launch_context: *mut GAppLaunchContext) -> gboolean;
    pub fn g_app_info_launch_uris(appinfo: *mut GAppInfo, uris: *mut glib::GList, launch_context: *mut GAppLaunchContext) -> gboolean;
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
    pub fn g_app_info_remove_supports_type(appinfo: *mut GAppInfo, content_type: *const gchar) -> gboolean;
    pub fn g_app_info_reset_type_associations(content_type: *const gchar);
    pub fn g_app_info_set_as_default_for_extension(appinfo: *mut GAppInfo, extension: *const gchar) -> gboolean;
    pub fn g_app_info_set_as_default_for_type(appinfo: *mut GAppInfo, content_type: *const gchar) -> gboolean;
    pub fn g_app_info_set_as_last_used_for_type(appinfo: *mut GAppInfo, content_type: *const gchar) -> gboolean;
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_launch_context_get_display(context: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut gchar;
    pub fn g_app_launch_context_get_environment(context: *mut GAppLaunchContext) -> *mut *mut gchar;
    pub fn g_app_launch_context_get_startup_notify_id(context: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut gchar;
    pub fn g_app_launch_context_launch_failed(context: *mut GAppLaunchContext, startup_notify_id: *const gchar);
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
    pub fn g_app_launch_context_setenv(context: *mut GAppLaunchContext, variable: *const gchar, value: *const gchar);
    pub fn g_app_launch_context_unsetenv(context: *mut GAppLaunchContext, variable: *const gchar);
    pub fn g_application_activate(application: *mut GApplication);
    pub fn g_application_add_main_option(application: *mut GApplication, long_name: *const gchar, short_name: gchar, flags: glib::GOptionFlags, arg: glib::GOptionArg, description: *const gchar, arg_description: *const gchar);
    pub fn g_application_add_main_option_entries(application: *mut GApplication, entries: *mut glib::GOptionEntry);
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut glib::GOptionGroup);
    pub fn g_application_bind_busy_property(application: *mut GApplication, object: gpointer, property: *const gchar);
    pub fn g_application_command_line_create_file_for_arg(cmdline: *mut GApplicationCommandLine, arg: *const gchar) -> *mut GFile;
    pub fn g_application_command_line_get_arguments(cmdline: *mut GApplicationCommandLine, argc: *mut gint) -> *mut *mut gchar;
    pub fn g_application_command_line_get_cwd(cmdline: *mut GApplicationCommandLine) -> *const gchar;
    pub fn g_application_command_line_get_environ(cmdline: *mut GApplicationCommandLine) -> *mut *mut gchar;
    pub fn g_application_command_line_get_exit_status(cmdline: *mut GApplicationCommandLine) -> gint;
    pub fn g_application_command_line_get_is_remote(cmdline: *mut GApplicationCommandLine) -> gboolean;
    pub fn g_application_command_line_get_options_dict(cmdline: *mut GApplicationCommandLine) -> *mut glib::GVariantDict;
    pub fn g_application_command_line_get_platform_data(cmdline: *mut GApplicationCommandLine) -> *mut glib::GVariant;
    pub fn g_application_command_line_get_stdin(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream;
    pub fn g_application_command_line_getenv(cmdline: *mut GApplicationCommandLine, name: *const gchar) -> *const gchar;
    pub fn g_application_command_line_print(cmdline: *mut GApplicationCommandLine, format: *const gchar, ...);
    pub fn g_application_command_line_printerr(cmdline: *mut GApplicationCommandLine, format: *const gchar, ...);
    pub fn g_application_command_line_set_exit_status(cmdline: *mut GApplicationCommandLine, exit_status: gint);
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const gchar;
    pub fn g_application_get_dbus_connection(application: *mut GApplication) -> *mut GDBusConnection;
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const gchar;
    pub fn g_application_get_default() -> *mut GApplication;
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> guint;
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const gchar;
    pub fn g_application_hold(application: *mut GApplication);
    pub fn g_application_id_is_valid(application_id: *const gchar) -> gboolean;
    pub fn g_application_mark_busy(application: *mut GApplication);
    pub fn g_application_new(application_id: *const gchar, flags: GApplicationFlags) -> *mut GApplication;
    pub fn g_application_open(application: *mut GApplication, files: *mut *mut GFile, n_files: gint, hint: *const gchar);
    pub fn g_application_quit(application: *mut GApplication);
    pub fn g_application_register(application: *mut GApplication, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_application_release(application: *mut GApplication);
    pub fn g_application_run(application: *mut GApplication, argc: gint, argv: *mut *mut gchar) -> gint;
    pub fn g_application_send_notification(application: *mut GApplication, id: *const gchar, notification: *mut GNotification);
    pub fn g_application_set_action_group(application: *mut GApplication, action_group: *mut GActionGroup);
    pub fn g_application_set_application_id(application: *mut GApplication, application_id: *const gchar);
    pub fn g_application_set_default(application: *mut GApplication);
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
    pub fn g_application_set_inactivity_timeout(application: *mut GApplication, inactivity_timeout: guint);
    pub fn g_application_set_resource_base_path(application: *mut GApplication, resource_path: *const gchar);
    pub fn g_application_unbind_busy_property(application: *mut GApplication, object: gpointer, property: *const gchar);
    pub fn g_application_unmark_busy(application: *mut GApplication);
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const gchar);
    pub fn g_async_initable_init_async(initable: *mut GAsyncInitable, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_async_initable_init_finish(initable: *mut GAsyncInitable, res: *mut GAsyncResult) -> gboolean;
    pub fn g_async_initable_new_async(object_type: GType, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer, first_property_name: *const gchar, ...);
    pub fn g_async_initable_new_finish(initable: *mut GAsyncInitable, res: *mut GAsyncResult) -> *mut gobject::GObject;
    pub fn g_async_initable_newv_async(object_type: GType, n_parameters: guint, parameters: *mut gobject::GParameter, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut gobject::GObject;
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
    pub fn g_async_result_legacy_propagate_error(res: *mut GAsyncResult) -> gboolean;
    pub fn g_buffered_input_stream_fill(stream: *mut GBufferedInputStream, count: gssize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_buffered_input_stream_fill_async(stream: *mut GBufferedInputStream, count: gssize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_buffered_input_stream_fill_finish(stream: *mut GBufferedInputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> gsize;
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> gsize;
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
    pub fn g_buffered_input_stream_new_sized(base_stream: *mut GInputStream, size: gsize) -> *mut GInputStream;
    pub fn g_buffered_input_stream_peek(stream: *mut GBufferedInputStream, buffer: *mut u8, offset: gsize, count: gsize) -> gsize;
    pub fn g_buffered_input_stream_peek_buffer(stream: *mut GBufferedInputStream, count: *mut gsize) -> *mut u8;
    pub fn g_buffered_input_stream_read_byte(stream: *mut GBufferedInputStream, cancellable: *mut GCancellable) -> gint;
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: gsize);
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> gsize;
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
    pub fn g_buffered_output_stream_new_sized(base_stream: *mut GOutputStream, size: gsize) -> *mut GOutputStream;
    pub fn g_buffered_output_stream_set_auto_grow(stream: *mut GBufferedOutputStream, auto_grow: gboolean);
    pub fn g_buffered_output_stream_set_buffer_size(stream: *mut GBufferedOutputStream, size: gsize);
    pub fn g_bus_get(bus_type: GBusType, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_bus_get_finish(res: *mut GAsyncResult) -> *mut GDBusConnection;
    pub fn g_bus_get_sync(bus_type: GBusType, cancellable: *mut GCancellable) -> *mut GDBusConnection;
    pub fn g_bus_own_name(bus_type: GBusType, name: *const gchar, flags: GBusNameOwnerFlags, bus_acquired_handler: Option<GBusAcquiredCallback>, name_acquired_handler: Option<GBusNameAcquiredCallback>, name_lost_handler: Option<GBusNameLostCallback>, user_data: gpointer, user_data_free_func: Option<glib::GDestroyNotify>) -> guint;
    pub fn g_bus_own_name_on_connection(connection: *mut GDBusConnection, name: *const gchar, flags: GBusNameOwnerFlags, name_acquired_handler: Option<GBusNameAcquiredCallback>, name_lost_handler: Option<GBusNameLostCallback>, user_data: gpointer, user_data_free_func: Option<glib::GDestroyNotify>) -> guint;
    pub fn g_bus_own_name_on_connection_with_closures(connection: *mut GDBusConnection, name: *const gchar, flags: GBusNameOwnerFlags, name_acquired_closure: *mut gobject::GClosure, name_lost_closure: *mut gobject::GClosure) -> guint;
    pub fn g_bus_own_name_with_closures(bus_type: GBusType, name: *const gchar, flags: GBusNameOwnerFlags, bus_acquired_closure: *mut gobject::GClosure, name_acquired_closure: *mut gobject::GClosure, name_lost_closure: *mut gobject::GClosure) -> guint;
    pub fn g_bus_unown_name(owner_id: guint);
    pub fn g_bus_unwatch_name(watcher_id: guint);
    pub fn g_bus_watch_name(bus_type: GBusType, name: *const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: Option<GBusNameAppearedCallback>, name_vanished_handler: Option<GBusNameVanishedCallback>, user_data: gpointer, user_data_free_func: Option<glib::GDestroyNotify>) -> guint;
    pub fn g_bus_watch_name_on_connection(connection: *mut GDBusConnection, name: *const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: Option<GBusNameAppearedCallback>, name_vanished_handler: Option<GBusNameVanishedCallback>, user_data: gpointer, user_data_free_func: Option<glib::GDestroyNotify>) -> guint;
    pub fn g_bus_watch_name_on_connection_with_closures(connection: *mut GDBusConnection, name: *const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: *mut gobject::GClosure, name_vanished_closure: *mut gobject::GClosure) -> guint;
    pub fn g_bus_watch_name_with_closures(bus_type: GBusType, name: *const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: *mut gobject::GClosure, name_vanished_closure: *mut gobject::GClosure) -> guint;
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut glib::GBytes;
    pub fn g_bytes_icon_new(bytes: *mut glib::GBytes) -> *mut GIcon;
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
    pub fn g_cancellable_connect(cancellable: *mut GCancellable, callback: gobject::GCallback, data: gpointer, data_destroy_func: Option<glib::GDestroyNotify>) -> gulong;
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: gulong);
    pub fn g_cancellable_get_current() -> *mut GCancellable;
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> gint;
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
    pub fn g_cancellable_make_pollfd(cancellable: *mut GCancellable, pollfd: *mut glib::GPollFD) -> gboolean;
    pub fn g_cancellable_new() -> *mut GCancellable;
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
    pub fn g_cancellable_set_error_if_cancelled(cancellable: *mut GCancellable) -> gboolean;
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> guint;
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
    pub fn g_charset_converter_new(to_charset: *const gchar, from_charset: *const gchar) -> *mut GCharsetConverter;
    pub fn g_charset_converter_set_use_fallback(converter: *mut GCharsetConverter, use_fallback: gboolean);
    pub fn g_content_type_can_be_executable(type_: *const gchar) -> gboolean;
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar) -> gboolean;
    pub fn g_content_type_from_mime_type(mime_type: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_description(type_: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_generic_icon_name(type_: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_icon(type_: *const gchar) -> *mut GIcon;
    pub fn g_content_type_get_mime_type(type_: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_symbolic_icon(type_: *const gchar) -> *mut GIcon;
    pub fn g_content_type_guess(filename: *const gchar, data: *mut u8, data_size: gsize, result_uncertain: *mut gboolean) -> *mut gchar;
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
    pub fn g_content_type_is_a(type_: *const gchar, supertype: *const gchar) -> gboolean;
    pub fn g_content_type_is_unknown(type_: *const gchar) -> gboolean;
    pub fn g_content_types_get_registered() -> *mut glib::GList;
    pub fn g_converter_convert(converter: *mut GConverter, inbuf: *mut u8, inbuf_size: gsize, outbuf: *mut u8, outbuf_size: gsize, flags: GConverterFlags, bytes_read: *mut gsize, bytes_written: *mut gsize) -> GConverterResult;
    pub fn g_converter_input_stream_get_converter(converter_stream: *mut GConverterInputStream) -> *mut GConverter;
    pub fn g_converter_input_stream_new(base_stream: *mut GInputStream, converter: *mut GConverter) -> *mut GInputStream;
    pub fn g_converter_output_stream_get_converter(converter_stream: *mut GConverterOutputStream) -> *mut GConverter;
    pub fn g_converter_output_stream_new(base_stream: *mut GOutputStream, converter: *mut GConverter) -> *mut GOutputStream;
    pub fn g_converter_reset(converter: *mut GConverter);
    pub fn g_credentials_get_native(credentials: *mut GCredentials, native_type: GCredentialsType) -> gpointer;
    pub fn g_credentials_is_same_user(credentials: *mut GCredentials, other_credentials: *mut GCredentials) -> gboolean;
    pub fn g_credentials_new() -> *mut GCredentials;
    pub fn g_credentials_set_native(credentials: *mut GCredentials, native_type: GCredentialsType, native: gpointer);
    pub fn g_credentials_set_unix_user(credentials: *mut GCredentials, uid: libc::uid_t) -> gboolean;
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut gchar;
    pub fn g_data_input_stream_get_byte_order(stream: *mut GDataInputStream) -> GDataStreamByteOrder;
    pub fn g_data_input_stream_get_newline_type(stream: *mut GDataInputStream) -> GDataStreamNewlineType;
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
    pub fn g_data_input_stream_read_byte(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> u8;
    pub fn g_data_input_stream_read_int16(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> i16;
    pub fn g_data_input_stream_read_int32(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> i32;
    pub fn g_data_input_stream_read_int64(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> i64;
    pub fn g_data_input_stream_read_line(stream: *mut GDataInputStream, length: *mut gsize, cancellable: *mut GCancellable) -> *mut u8;
    pub fn g_data_input_stream_read_line_async(stream: *mut GDataInputStream, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_data_input_stream_read_line_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut gsize) -> *mut u8;
    pub fn g_data_input_stream_read_line_finish_utf8(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut gsize) -> *mut gchar;
    pub fn g_data_input_stream_read_line_utf8(stream: *mut GDataInputStream, length: *mut gsize, cancellable: *mut GCancellable) -> *mut gchar;
    pub fn g_data_input_stream_read_uint16(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> u16;
    pub fn g_data_input_stream_read_uint32(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> u32;
    pub fn g_data_input_stream_read_uint64(stream: *mut GDataInputStream, cancellable: *mut GCancellable) -> u64;
    pub fn g_data_input_stream_read_until(stream: *mut GDataInputStream, stop_chars: *const gchar, length: *mut gsize, cancellable: *mut GCancellable) -> *mut gchar;
    pub fn g_data_input_stream_read_until_async(stream: *mut GDataInputStream, stop_chars: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_data_input_stream_read_until_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut gsize) -> *mut gchar;
    pub fn g_data_input_stream_read_upto(stream: *mut GDataInputStream, stop_chars: *const gchar, stop_chars_len: gssize, length: *mut gsize, cancellable: *mut GCancellable) -> *mut gchar;
    pub fn g_data_input_stream_read_upto_async(stream: *mut GDataInputStream, stop_chars: *const gchar, stop_chars_len: gssize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_data_input_stream_read_upto_finish(stream: *mut GDataInputStream, result: *mut GAsyncResult, length: *mut gsize) -> *mut gchar;
    pub fn g_data_input_stream_set_byte_order(stream: *mut GDataInputStream, order: GDataStreamByteOrder);
    pub fn g_data_input_stream_set_newline_type(stream: *mut GDataInputStream, type_: GDataStreamNewlineType);
    pub fn g_data_output_stream_get_byte_order(stream: *mut GDataOutputStream) -> GDataStreamByteOrder;
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
    pub fn g_data_output_stream_put_byte(stream: *mut GDataOutputStream, data: u8, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_int16(stream: *mut GDataOutputStream, data: i16, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_int32(stream: *mut GDataOutputStream, data: i32, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_int64(stream: *mut GDataOutputStream, data: i64, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_string(stream: *mut GDataOutputStream, str: *const gchar, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_uint16(stream: *mut GDataOutputStream, data: u16, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_uint32(stream: *mut GDataOutputStream, data: u32, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_put_uint64(stream: *mut GDataOutputStream, data: u64, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_data_output_stream_set_byte_order(stream: *mut GDataOutputStream, order: GDataStreamByteOrder);
    pub fn g_datagram_based_condition_check(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition) -> glib::GIOCondition;
    pub fn g_datagram_based_condition_wait(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition, timeout: i64, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_datagram_based_create_source(datagram_based: *mut GDatagramBased, condition: glib::GIOCondition, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_datagram_based_receive_messages(datagram_based: *mut GDatagramBased, messages: *mut GInputMessage, num_messages: guint, flags: gint, timeout: i64, cancellable: *mut GCancellable) -> gint;
    pub fn g_datagram_based_send_messages(datagram_based: *mut GDatagramBased, messages: *mut GOutputMessage, num_messages: guint, flags: gint, timeout: i64, cancellable: *mut GCancellable) -> gint;
    pub fn g_dbus_action_group_get(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar) -> *mut GDBusActionGroup;
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
    pub fn g_dbus_address_get_for_bus_sync(bus_type: GBusType, cancellable: *mut GCancellable) -> *mut gchar;
    pub fn g_dbus_address_get_stream(address: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_address_get_stream_finish(res: *mut GAsyncResult, out_guid: *mut *mut gchar) -> *mut GIOStream;
    pub fn g_dbus_address_get_stream_sync(address: *const gchar, out_guid: *mut *mut gchar, cancellable: *mut GCancellable) -> *mut GIOStream;
    pub fn g_dbus_annotation_info_lookup(annotations: *mut *mut GDBusAnnotationInfo, name: *const gchar) -> *const gchar;
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
    pub fn g_dbus_auth_observer_allow_mechanism(observer: *mut GDBusAuthObserver, mechanism: *const gchar) -> gboolean;
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(observer: *mut GDBusAuthObserver, stream: *mut GIOStream, credentials: *mut GCredentials) -> gboolean;
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
    pub fn g_dbus_connection_add_filter(connection: *mut GDBusConnection, filter_function: GDBusMessageFilterFunction, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> guint;
    pub fn g_dbus_connection_call(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar, interface_name: *const gchar, method_name: *const gchar, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_call_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_sync(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar, interface_name: *const gchar, method_name: *const gchar, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: *mut GCancellable) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar, interface_name: *const gchar, method_name: *const gchar, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: *mut GUnixFDList, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(connection: *mut GDBusConnection, out_fd_list: *mut *mut GUnixFDList, res: *mut GAsyncResult) -> *mut glib::GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar, interface_name: *const gchar, method_name: *const gchar, parameters: *mut glib::GVariant, reply_type: *const glib::GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: *mut GUnixFDList, out_fd_list: *mut *mut GUnixFDList, cancellable: *mut GCancellable) -> *mut glib::GVariant;
    pub fn g_dbus_connection_close(connection: *mut GDBusConnection, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_close_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult) -> gboolean;
    pub fn g_dbus_connection_close_sync(connection: *mut GDBusConnection, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_dbus_connection_emit_signal(connection: *mut GDBusConnection, destination_bus_name: *const gchar, object_path: *const gchar, interface_name: *const gchar, signal_name: *const gchar, parameters: *mut glib::GVariant) -> gboolean;
    pub fn g_dbus_connection_export_action_group(connection: *mut GDBusConnection, object_path: *const gchar, action_group: *mut GActionGroup) -> guint;
    pub fn g_dbus_connection_export_menu_model(connection: *mut GDBusConnection, object_path: *const gchar, menu: *mut GMenuModel) -> guint;
    pub fn g_dbus_connection_flush(connection: *mut GDBusConnection, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_flush_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult) -> gboolean;
    pub fn g_dbus_connection_flush_sync(connection: *mut GDBusConnection, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_dbus_connection_get_capabilities(connection: *mut GDBusConnection) -> GDBusCapabilityFlags;
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const gchar;
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> u32;
    pub fn g_dbus_connection_get_peer_credentials(connection: *mut GDBusConnection) -> *mut GCredentials;
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const gchar;
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_connection_new(stream: *mut GIOStream, guid: *const gchar, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_new_finish(res: *mut GAsyncResult) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address(address: *const gchar, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_new_for_address_finish(res: *mut GAsyncResult) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address_sync(address: *const gchar, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_sync(stream: *mut GIOStream, guid: *const gchar, flags: GDBusConnectionFlags, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable) -> *mut GDBusConnection;
    pub fn g_dbus_connection_register_object(connection: *mut GDBusConnection, object_path: *const gchar, interface_info: *mut GDBusInterfaceInfo, vtable: *const GDBusInterfaceVTable, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> guint;
    pub fn g_dbus_connection_register_object_with_closures(connection: *mut GDBusConnection, object_path: *const gchar, interface_info: *mut GDBusInterfaceInfo, method_call_closure: *mut gobject::GClosure, get_property_closure: *mut gobject::GClosure, set_property_closure: *mut gobject::GClosure) -> guint;
    pub fn g_dbus_connection_register_subtree(connection: *mut GDBusConnection, object_path: *const gchar, vtable: *const GDBusSubtreeVTable, flags: GDBusSubtreeFlags, user_data: gpointer, user_data_free_func: glib::GDestroyNotify) -> guint;
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: guint);
    pub fn g_dbus_connection_send_message(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, out_serial: *mut u32) -> gboolean;
    pub fn g_dbus_connection_send_message_with_reply(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: *mut u32, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_connection_send_message_with_reply_finish(connection: *mut GDBusConnection, res: *mut GAsyncResult) -> *mut GDBusMessage;
    pub fn g_dbus_connection_send_message_with_reply_sync(connection: *mut GDBusConnection, message: *mut GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: *mut u32, cancellable: *mut GCancellable) -> *mut GDBusMessage;
    pub fn g_dbus_connection_set_exit_on_close(connection: *mut GDBusConnection, exit_on_close: gboolean);
    pub fn g_dbus_connection_signal_subscribe(connection: *mut GDBusConnection, sender: *const gchar, interface_name: *const gchar, member: *const gchar, object_path: *const gchar, arg0: *const gchar, flags: GDBusSignalFlags, callback: GDBusSignalCallback, user_data: gpointer, user_data_free_func: Option<glib::GDestroyNotify>) -> guint;
    pub fn g_dbus_connection_signal_unsubscribe(connection: *mut GDBusConnection, subscription_id: guint);
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
    pub fn g_dbus_connection_unexport_action_group(connection: *mut GDBusConnection, export_id: guint);
    pub fn g_dbus_connection_unexport_menu_model(connection: *mut GDBusConnection, export_id: guint);
    pub fn g_dbus_connection_unregister_object(connection: *mut GDBusConnection, registration_id: guint) -> gboolean;
    pub fn g_dbus_connection_unregister_subtree(connection: *mut GDBusConnection, registration_id: guint) -> gboolean;
    pub fn g_dbus_error_encode_gerror(error: *const glib::GError) -> *mut gchar;
    pub fn g_dbus_error_get_remote_error(error: *const glib::GError) -> *mut gchar;
    pub fn g_dbus_error_is_remote_error(error: *const glib::GError) -> gboolean;
    pub fn g_dbus_error_new_for_dbus_error(dbus_error_name: *const gchar, dbus_error_message: *const gchar) -> *mut glib::GError;
    pub fn g_dbus_error_quark() -> glib::GQuark;
    pub fn g_dbus_error_register_error(error_domain: glib::GQuark, error_code: gint, dbus_error_name: *const gchar) -> gboolean;
    pub fn g_dbus_error_register_error_domain(error_domain_quark_name: *const gchar, quark_volatile: gsize, entries: *const GDBusErrorEntry, num_entries: guint);
    pub fn g_dbus_error_set_dbus_error(error: *mut *mut glib::GError, dbus_error_name: *const gchar, dbus_error_message: *const gchar, format: *const gchar, ...);
    pub fn g_dbus_error_strip_remote_error(error: *mut glib::GError) -> gboolean;
    pub fn g_dbus_error_unregister_error(error_domain: glib::GQuark, error_code: gint, dbus_error_name: *const gchar) -> gboolean;
    pub fn g_dbus_generate_guid() -> *mut gchar;
    pub fn g_dbus_gvalue_to_gvariant(gvalue: *const gobject::GValue, type_: *const glib::GVariantType) -> *mut glib::GVariant;
    pub fn g_dbus_gvariant_to_gvalue(value: *mut glib::GVariant, out_gvalue: *mut gobject::GValue);
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_generate_xml(info: *mut GDBusInterfaceInfo, indent: guint, string_builder: *mut glib::GString);
    pub fn g_dbus_interface_info_lookup_method(info: *mut GDBusInterfaceInfo, name: *const gchar) -> *mut GDBusMethodInfo;
    pub fn g_dbus_interface_info_lookup_property(info: *mut GDBusInterfaceInfo, name: *const gchar) -> *mut GDBusPropertyInfo;
    pub fn g_dbus_interface_info_lookup_signal(info: *mut GDBusInterfaceInfo, name: *const gchar) -> *mut GDBusSignalInfo;
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);
    pub fn g_dbus_interface_skeleton_export(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection, object_path: *const gchar) -> gboolean;
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_get_connection(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusConnection;
    pub fn g_dbus_interface_skeleton_get_connections(interface_: *mut GDBusInterfaceSkeleton) -> *mut glib::GList;
    pub fn g_dbus_interface_skeleton_get_flags(interface_: *mut GDBusInterfaceSkeleton) -> GDBusInterfaceSkeletonFlags;
    pub fn g_dbus_interface_skeleton_get_info(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_skeleton_get_object_path(interface_: *mut GDBusInterfaceSkeleton) -> *const gchar;
    pub fn g_dbus_interface_skeleton_get_properties(interface_: *mut GDBusInterfaceSkeleton) -> *mut glib::GVariant;
    pub fn g_dbus_interface_skeleton_get_vtable(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable;
    pub fn g_dbus_interface_skeleton_has_connection(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection) -> gboolean;
    pub fn g_dbus_interface_skeleton_set_flags(interface_: *mut GDBusInterfaceSkeleton, flags: GDBusInterfaceSkeletonFlags);
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_unexport_from_connection(interface_: *mut GDBusInterfaceSkeleton, connection: *mut GDBusConnection);
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_supported_address(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_menu_model_get(connection: *mut GDBusConnection, bus_name: *const gchar, object_path: *const gchar) -> *mut GDBusMenuModel;
    pub fn g_dbus_message_bytes_needed(blob: *mut u8, blob_len: gsize) -> gssize;
    pub fn g_dbus_message_copy(message: *mut GDBusMessage) -> *mut GDBusMessage;
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut glib::GVariant;
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
    pub fn g_dbus_message_get_header(message: *mut GDBusMessage, header_field: GDBusMessageHeaderField) -> *mut glib::GVariant;
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut u8;
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> u32;
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const gchar;
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
    pub fn g_dbus_message_new_from_blob(blob: *mut u8, blob_len: gsize, capabilities: GDBusCapabilityFlags) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_call(name: *const gchar, path: *const gchar, interface_: *const gchar, method: *const gchar) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error(method_call_message: *mut GDBusMessage, error_name: *const gchar, error_message_format: *const gchar, ...) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error_literal(method_call_message: *mut GDBusMessage, error_name: *const gchar, error_message: *const gchar) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_reply(method_call_message: *mut GDBusMessage) -> *mut GDBusMessage;
    pub fn g_dbus_message_new_signal(path: *const gchar, interface_: *const gchar, signal: *const gchar) -> *mut GDBusMessage;
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint) -> *mut gchar;
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut glib::GVariant);
    pub fn g_dbus_message_set_byte_order(message: *mut GDBusMessage, byte_order: GDBusMessageByteOrder);
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
    pub fn g_dbus_message_set_header(message: *mut GDBusMessage, header_field: GDBusMessageHeaderField, value: *mut glib::GVariant);
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: u32);
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: u32);
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: u32);
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const gchar);
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
    pub fn g_dbus_message_to_blob(message: *mut GDBusMessage, out_size: *mut gsize, capabilities: GDBusCapabilityFlags) -> *mut u8;
    pub fn g_dbus_message_to_gerror(message: *mut GDBusMessage) -> gboolean;
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
    pub fn g_dbus_method_invocation_get_connection(invocation: *mut GDBusMethodInvocation) -> *mut GDBusConnection;
    pub fn g_dbus_method_invocation_get_interface_name(invocation: *mut GDBusMethodInvocation) -> *const gchar;
    pub fn g_dbus_method_invocation_get_message(invocation: *mut GDBusMethodInvocation) -> *mut GDBusMessage;
    pub fn g_dbus_method_invocation_get_method_info(invocation: *mut GDBusMethodInvocation) -> *const GDBusMethodInfo;
    pub fn g_dbus_method_invocation_get_method_name(invocation: *mut GDBusMethodInvocation) -> *const gchar;
    pub fn g_dbus_method_invocation_get_object_path(invocation: *mut GDBusMethodInvocation) -> *const gchar;
    pub fn g_dbus_method_invocation_get_parameters(invocation: *mut GDBusMethodInvocation) -> *mut glib::GVariant;
    pub fn g_dbus_method_invocation_get_property_info(invocation: *mut GDBusMethodInvocation) -> *const GDBusPropertyInfo;
    pub fn g_dbus_method_invocation_get_sender(invocation: *mut GDBusMethodInvocation) -> *const gchar;
    pub fn g_dbus_method_invocation_get_user_data(invocation: *mut GDBusMethodInvocation) -> gpointer;
    pub fn g_dbus_method_invocation_return_dbus_error(invocation: *mut GDBusMethodInvocation, error_name: *const gchar, error_message: *const gchar);
    pub fn g_dbus_method_invocation_return_error(invocation: *mut GDBusMethodInvocation, domain: glib::GQuark, code: gint, format: *const gchar, ...);
    pub fn g_dbus_method_invocation_return_error_literal(invocation: *mut GDBusMethodInvocation, domain: glib::GQuark, code: gint, message: *const gchar);
    pub fn g_dbus_method_invocation_return_gerror(invocation: *mut GDBusMethodInvocation, error: *const glib::GError);
    pub fn g_dbus_method_invocation_return_value(invocation: *mut GDBusMethodInvocation, parameters: *mut glib::GVariant);
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(invocation: *mut GDBusMethodInvocation, parameters: *mut glib::GVariant, fd_list: *mut GUnixFDList);
    pub fn g_dbus_method_invocation_take_error(invocation: *mut GDBusMethodInvocation, error: *mut glib::GError);
    pub fn g_dbus_node_info_generate_xml(info: *mut GDBusNodeInfo, indent: guint, string_builder: *mut glib::GString);
    pub fn g_dbus_node_info_lookup_interface(info: *mut GDBusNodeInfo, name: *const gchar) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_node_info_new_for_xml(xml_data: *const gchar) -> *mut GDBusNodeInfo;
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
    pub fn g_dbus_object_get_interface(object: *mut GDBusObject, interface_name: *const gchar) -> *mut GDBusInterface;
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut glib::GList;
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const gchar;
    pub fn g_dbus_object_manager_client_get_connection(manager: *mut GDBusObjectManagerClient) -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_client_get_flags(manager: *mut GDBusObjectManagerClient) -> GDBusObjectManagerClientFlags;
    pub fn g_dbus_object_manager_client_get_name(manager: *mut GDBusObjectManagerClient) -> *const gchar;
    pub fn g_dbus_object_manager_client_get_name_owner(manager: *mut GDBusObjectManagerClient) -> *mut gchar;
    pub fn g_dbus_object_manager_client_new(connection: *mut GDBusConnection, flags: GDBusObjectManagerClientFlags, name: *const gchar, object_path: *const gchar, get_proxy_type_func: Option<GDBusProxyTypeFunc>, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: Option<glib::GDestroyNotify>, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_object_manager_client_new_finish(res: *mut GAsyncResult) -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_for_bus(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: *const gchar, object_path: *const gchar, get_proxy_type_func: Option<GDBusProxyTypeFunc>, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: Option<glib::GDestroyNotify>, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_object_manager_client_new_for_bus_finish(res: *mut GAsyncResult) -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_for_bus_sync(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: *const gchar, object_path: *const gchar, get_proxy_type_func: Option<GDBusProxyTypeFunc>, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: Option<glib::GDestroyNotify>, cancellable: *mut GCancellable) -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_sync(connection: *mut GDBusConnection, flags: GDBusObjectManagerClientFlags, name: *const gchar, object_path: *const gchar, get_proxy_type_func: Option<GDBusProxyTypeFunc>, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: Option<glib::GDestroyNotify>, cancellable: *mut GCancellable) -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_get_interface(manager: *mut GDBusObjectManager, object_path: *const gchar, interface_name: *const gchar) -> *mut GDBusInterface;
    pub fn g_dbus_object_manager_get_object(manager: *mut GDBusObjectManager, object_path: *const gchar) -> *mut GDBusObject;
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const gchar;
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut glib::GList;
    pub fn g_dbus_object_manager_server_export(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_export_uniquely(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_get_connection(manager: *mut GDBusObjectManagerServer) -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_server_is_exported(manager: *mut GDBusObjectManagerServer, object: *mut GDBusObjectSkeleton) -> gboolean;
    pub fn g_dbus_object_manager_server_new(object_path: *const gchar) -> *mut GDBusObjectManagerServer;
    pub fn g_dbus_object_manager_server_set_connection(manager: *mut GDBusObjectManagerServer, connection: *mut GDBusConnection);
    pub fn g_dbus_object_manager_server_unexport(manager: *mut GDBusObjectManagerServer, object_path: *const gchar) -> gboolean;
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy) -> *mut GDBusConnection;
    pub fn g_dbus_object_proxy_new(connection: *mut GDBusConnection, object_path: *const gchar) -> *mut GDBusObjectProxy;
    pub fn g_dbus_object_skeleton_add_interface(object: *mut GDBusObjectSkeleton, interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar) -> *mut GDBusObjectSkeleton;
    pub fn g_dbus_object_skeleton_remove_interface(object: *mut GDBusObjectSkeleton, interface_: *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_remove_interface_by_name(object: *mut GDBusObjectSkeleton, interface_name: *const gchar);
    pub fn g_dbus_object_skeleton_set_object_path(object: *mut GDBusObjectSkeleton, object_path: *const gchar);
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
    pub fn g_dbus_proxy_call(proxy: *mut GDBusProxy, method_name: *const gchar, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_proxy_call_finish(proxy: *mut GDBusProxy, res: *mut GAsyncResult) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_sync(proxy: *mut GDBusProxy, method_name: *const gchar, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: *mut GCancellable) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list(proxy: *mut GDBusProxy, method_name: *const gchar, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: *mut GUnixFDList, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(proxy: *mut GDBusProxy, out_fd_list: *mut *mut GUnixFDList, res: *mut GAsyncResult) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(proxy: *mut GDBusProxy, method_name: *const gchar, parameters: *mut glib::GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: *mut GUnixFDList, out_fd_list: *mut *mut GUnixFDList, cancellable: *mut GCancellable) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_get_cached_property(proxy: *mut GDBusProxy, property_name: *const gchar) -> *mut glib::GVariant;
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut gchar;
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const gchar;
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const gchar;
    pub fn g_dbus_proxy_new(connection: *mut GDBusConnection, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const gchar, object_path: *const gchar, interface_name: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_proxy_new_finish(res: *mut GAsyncResult) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus(bus_type: GBusType, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const gchar, object_path: *const gchar, interface_name: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_dbus_proxy_new_for_bus_finish(res: *mut GAsyncResult) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus_sync(bus_type: GBusType, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const gchar, object_path: *const gchar, interface_name: *const gchar, cancellable: *mut GCancellable) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_sync(connection: *mut GDBusConnection, flags: GDBusProxyFlags, info: *mut GDBusInterfaceInfo, name: *const gchar, object_path: *const gchar, interface_name: *const gchar, cancellable: *mut GCancellable) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_set_cached_property(proxy: *mut GDBusProxy, property_name: *const gchar, value: *mut glib::GVariant);
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: gint);
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const gchar;
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
    pub fn g_dbus_server_new_sync(address: *const gchar, flags: GDBusServerFlags, guid: *const gchar, observer: *mut GDBusAuthObserver, cancellable: *mut GCancellable) -> *mut GDBusServer;
    pub fn g_dbus_server_start(server: *mut GDBusServer);
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_eject(drive: *mut GDrive, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_drive_eject_finish(drive: *mut GDrive, result: *mut GAsyncResult) -> gboolean;
    pub fn g_drive_eject_with_operation(drive: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_drive_eject_with_operation_finish(drive: *mut GDrive, result: *mut GAsyncResult) -> gboolean;
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut gchar;
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_get_identifier(drive: *mut GDrive, kind: *const gchar) -> *mut gchar;
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut gchar;
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut glib::GList;
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_poll_for_media(drive: *mut GDrive, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_drive_poll_for_media_finish(drive: *mut GDrive, result: *mut GAsyncResult) -> gboolean;
    pub fn g_drive_start(drive: *mut GDrive, flags: GDriveStartFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_drive_start_finish(drive: *mut GDrive, result: *mut GAsyncResult) -> gboolean;
    pub fn g_drive_stop(drive: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_drive_stop_finish(drive: *mut GDrive, result: *mut GAsyncResult) -> gboolean;
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut glib::GList;
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GIcon;
    pub fn g_file_append_to(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable) -> *mut GFileOutputStream;
    pub fn g_file_append_to_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_append_to_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileOutputStream;
    pub fn g_file_attribute_info_list_add(list: *mut GFileAttributeInfoList, name: *const gchar, type_: GFileAttributeType, flags: GFileAttributeInfoFlags);
    pub fn g_file_attribute_info_list_dup(list: *mut GFileAttributeInfoList) -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_lookup(list: *mut GFileAttributeInfoList, name: *const gchar) -> *const GFileAttributeInfo;
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_ref(list: *mut GFileAttributeInfoList) -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);
    pub fn g_file_attribute_matcher_enumerate_namespace(matcher: *mut GFileAttributeMatcher, ns: *const gchar) -> gboolean;
    pub fn g_file_attribute_matcher_enumerate_next(matcher: *mut GFileAttributeMatcher) -> *const gchar;
    pub fn g_file_attribute_matcher_matches(matcher: *mut GFileAttributeMatcher, attribute: *const gchar) -> gboolean;
    pub fn g_file_attribute_matcher_matches_only(matcher: *mut GFileAttributeMatcher, attribute: *const gchar) -> gboolean;
    pub fn g_file_attribute_matcher_new(attributes: *const gchar) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_ref(matcher: *mut GFileAttributeMatcher) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_subtract(matcher: *mut GFileAttributeMatcher, subtract: *mut GFileAttributeMatcher) -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_to_string(matcher: *mut GFileAttributeMatcher) -> *mut gchar;
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);
    pub fn g_file_copy(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable, progress_callback: Option<GFileProgressCallback>, progress_callback_data: gpointer) -> gboolean;
    pub fn g_file_copy_async(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, io_priority: gint, cancellable: *mut GCancellable, progress_callback: Option<GFileProgressCallback>, progress_callback_data: gpointer, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_copy_attributes(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_copy_finish(file: *mut GFile, res: *mut GAsyncResult) -> gboolean;
    pub fn g_file_create(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable) -> *mut GFileOutputStream;
    pub fn g_file_create_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_create_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileOutputStream;
    pub fn g_file_create_readwrite(file: *mut GFile, flags: GFileCreateFlags, cancellable: *mut GCancellable) -> *mut GFileIOStream;
    pub fn g_file_create_readwrite_async(file: *mut GFile, flags: GFileCreateFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_create_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileIOStream;
    pub fn g_file_delete(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_delete_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_delete_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
    pub fn g_file_eject_mountable(file: *mut GFile, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_eject_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_eject_mountable_with_operation(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_eject_mountable_with_operation_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_enumerate_children(file: *mut GFile, attributes: *const gchar, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> *mut GFileEnumerator;
    pub fn g_file_enumerate_children_async(file: *mut GFile, attributes: *const gchar, flags: GFileQueryInfoFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_enumerate_children_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileEnumerator;
    pub fn g_file_enumerator_close(enumerator: *mut GFileEnumerator, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_enumerator_close_async(enumerator: *mut GFileEnumerator, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_enumerator_close_finish(enumerator: *mut GFileEnumerator, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_enumerator_get_child(enumerator: *mut GFileEnumerator, info: *mut GFileInfo) -> *mut GFile;
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
    pub fn g_file_enumerator_iterate(direnum: *mut GFileEnumerator, out_info: *mut *mut GFileInfo, out_child: *mut *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_enumerator_next_file(enumerator: *mut GFileEnumerator, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_enumerator_next_files_async(enumerator: *mut GFileEnumerator, num_files: gint, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_enumerator_next_files_finish(enumerator: *mut GFileEnumerator, result: *mut GAsyncResult) -> *mut glib::GList;
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
    pub fn g_file_find_enclosing_mount(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GMount;
    pub fn g_file_find_enclosing_mount_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_find_enclosing_mount_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GMount;
    pub fn g_file_get_basename(file: *mut GFile) -> *mut gchar;
    pub fn g_file_get_child(file: *mut GFile, name: *const gchar) -> *mut GFile;
    pub fn g_file_get_child_for_display_name(file: *mut GFile, display_name: *const gchar) -> *mut GFile;
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut gchar;
    pub fn g_file_get_path(file: *mut GFile) -> *mut gchar;
    pub fn g_file_get_relative_path(parent: *mut GFile, descendant: *mut GFile) -> *mut gchar;
    pub fn g_file_get_uri(file: *mut GFile) -> *mut gchar;
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut gchar;
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
    pub fn g_file_has_uri_scheme(file: *mut GFile, uri_scheme: *const gchar) -> gboolean;
    pub fn g_file_hash(file: gconstpointer) -> guint;
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
    pub fn g_file_info_get_attribute_as_string(info: *mut GFileInfo, attribute: *const gchar) -> *mut gchar;
    pub fn g_file_info_get_attribute_boolean(info: *mut GFileInfo, attribute: *const gchar) -> gboolean;
    pub fn g_file_info_get_attribute_byte_string(info: *mut GFileInfo, attribute: *const gchar) -> *const gchar;
    pub fn g_file_info_get_attribute_data(info: *mut GFileInfo, attribute: *const gchar, type_: *mut GFileAttributeType, value_pp: *mut gpointer, status: *mut GFileAttributeStatus) -> gboolean;
    pub fn g_file_info_get_attribute_int32(info: *mut GFileInfo, attribute: *const gchar) -> i32;
    pub fn g_file_info_get_attribute_int64(info: *mut GFileInfo, attribute: *const gchar) -> i64;
    pub fn g_file_info_get_attribute_object(info: *mut GFileInfo, attribute: *const gchar) -> *mut gobject::GObject;
    pub fn g_file_info_get_attribute_status(info: *mut GFileInfo, attribute: *const gchar) -> GFileAttributeStatus;
    pub fn g_file_info_get_attribute_string(info: *mut GFileInfo, attribute: *const gchar) -> *const gchar;
    pub fn g_file_info_get_attribute_stringv(info: *mut GFileInfo, attribute: *const gchar) -> *mut *mut gchar;
    pub fn g_file_info_get_attribute_type(info: *mut GFileInfo, attribute: *const gchar) -> GFileAttributeType;
    pub fn g_file_info_get_attribute_uint32(info: *mut GFileInfo, attribute: *const gchar) -> u32;
    pub fn g_file_info_get_attribute_uint64(info: *mut GFileInfo, attribute: *const gchar) -> u64;
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut glib::GDateTime;
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut glib::GTimeVal);
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> i64;
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> i32;
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const gchar;
    pub fn g_file_info_has_attribute(info: *mut GFileInfo, attribute: *const gchar) -> gboolean;
    pub fn g_file_info_has_namespace(info: *mut GFileInfo, name_space: *const gchar) -> gboolean;
    pub fn g_file_info_list_attributes(info: *mut GFileInfo, name_space: *const gchar) -> *mut *mut gchar;
    pub fn g_file_info_new() -> *mut GFileInfo;
    pub fn g_file_info_remove_attribute(info: *mut GFileInfo, attribute: *const gchar);
    pub fn g_file_info_set_attribute(info: *mut GFileInfo, attribute: *const gchar, type_: GFileAttributeType, value_p: gpointer);
    pub fn g_file_info_set_attribute_boolean(info: *mut GFileInfo, attribute: *const gchar, attr_value: gboolean);
    pub fn g_file_info_set_attribute_byte_string(info: *mut GFileInfo, attribute: *const gchar, attr_value: *const gchar);
    pub fn g_file_info_set_attribute_int32(info: *mut GFileInfo, attribute: *const gchar, attr_value: i32);
    pub fn g_file_info_set_attribute_int64(info: *mut GFileInfo, attribute: *const gchar, attr_value: i64);
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
    pub fn g_file_info_set_attribute_object(info: *mut GFileInfo, attribute: *const gchar, attr_value: *mut gobject::GObject);
    pub fn g_file_info_set_attribute_status(info: *mut GFileInfo, attribute: *const gchar, status: GFileAttributeStatus) -> gboolean;
    pub fn g_file_info_set_attribute_string(info: *mut GFileInfo, attribute: *const gchar, attr_value: *const gchar);
    pub fn g_file_info_set_attribute_stringv(info: *mut GFileInfo, attribute: *const gchar, attr_value: *mut *mut gchar);
    pub fn g_file_info_set_attribute_uint32(info: *mut GFileInfo, attribute: *const gchar, attr_value: u32);
    pub fn g_file_info_set_attribute_uint64(info: *mut GFileInfo, attribute: *const gchar, attr_value: u64);
    pub fn g_file_info_set_content_type(info: *mut GFileInfo, content_type: *const gchar);
    pub fn g_file_info_set_display_name(info: *mut GFileInfo, display_name: *const gchar);
    pub fn g_file_info_set_edit_name(info: *mut GFileInfo, edit_name: *const gchar);
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut glib::GTimeVal);
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *const gchar);
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: i64);
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: i32);
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
    pub fn g_file_info_set_symlink_target(info: *mut GFileInfo, symlink_target: *const gchar);
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
    pub fn g_file_input_stream_query_info(stream: *mut GFileInputStream, attributes: *const gchar, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_input_stream_query_info_async(stream: *mut GFileInputStream, attributes: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_input_stream_query_info_finish(stream: *mut GFileInputStream, result: *mut GAsyncResult) -> *mut GFileInfo;
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut gchar;
    pub fn g_file_io_stream_query_info(stream: *mut GFileIOStream, attributes: *const gchar, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_io_stream_query_info_async(stream: *mut GFileIOStream, attributes: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_io_stream_query_info_finish(stream: *mut GFileIOStream, result: *mut GAsyncResult) -> *mut GFileInfo;
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
    pub fn g_file_load_contents(file: *mut GFile, cancellable: *mut GCancellable, contents: *mut *mut u8, length: *mut gsize, etag_out: *mut *mut gchar) -> gboolean;
    pub fn g_file_load_contents_async(file: *mut GFile, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_load_contents_finish(file: *mut GFile, res: *mut GAsyncResult, contents: *mut *mut u8, length: *mut gsize, etag_out: *mut *mut gchar) -> gboolean;
    pub fn g_file_load_partial_contents_async(file: *mut GFile, cancellable: *mut GCancellable, read_more_callback: GFileReadMoreCallback, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_load_partial_contents_finish(file: *mut GFile, res: *mut GAsyncResult, contents: *mut *mut u8, length: *mut gsize, etag_out: *mut *mut gchar) -> gboolean;
    pub fn g_file_make_directory(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_make_directory_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_make_directory_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_make_directory_with_parents(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_make_symbolic_link(file: *mut GFile, symlink_value: *const gchar, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_measure_disk_usage(file: *mut GFile, flags: GFileMeasureFlags, cancellable: *mut GCancellable, progress_callback: Option<GFileMeasureProgressCallback>, progress_data: gpointer, disk_usage: *mut u64, num_dirs: *mut u64, num_files: *mut u64) -> gboolean;
    pub fn g_file_measure_disk_usage_async(file: *mut GFile, flags: GFileMeasureFlags, io_priority: gint, cancellable: *mut GCancellable, progress_callback: Option<GFileMeasureProgressCallback>, progress_data: gpointer, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_measure_disk_usage_finish(file: *mut GFile, result: *mut GAsyncResult, disk_usage: *mut u64, num_dirs: *mut u64, num_files: *mut u64) -> gboolean;
    pub fn g_file_monitor(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable) -> *mut GFileMonitor;
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
    pub fn g_file_monitor_directory(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable) -> *mut GFileMonitor;
    pub fn g_file_monitor_emit_event(monitor: *mut GFileMonitor, child: *mut GFile, other_file: *mut GFile, event_type: GFileMonitorEvent);
    pub fn g_file_monitor_file(file: *mut GFile, flags: GFileMonitorFlags, cancellable: *mut GCancellable) -> *mut GFileMonitor;
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: gint);
    pub fn g_file_mount_enclosing_volume(location: *mut GFile, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_mount_enclosing_volume_finish(location: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_mount_mountable(file: *mut GFile, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_mount_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> *mut GFile;
    pub fn g_file_move(source: *mut GFile, destination: *mut GFile, flags: GFileCopyFlags, cancellable: *mut GCancellable, progress_callback: Option<GFileProgressCallback>, progress_callback_data: gpointer) -> gboolean;
    pub fn g_file_new_for_commandline_arg(arg: *const gchar) -> *mut GFile;
    pub fn g_file_new_for_commandline_arg_and_cwd(arg: *const gchar, cwd: *const gchar) -> *mut GFile;
    pub fn g_file_new_for_path(path: *const gchar) -> *mut GFile;
    pub fn g_file_new_for_uri(uri: *const gchar) -> *mut GFile;
    pub fn g_file_new_tmp(tmpl: *mut gchar, iostream: *mut *mut GFileIOStream) -> *mut GFile;
    pub fn g_file_open_readwrite(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GFileIOStream;
    pub fn g_file_open_readwrite_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_open_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileIOStream;
    pub fn g_file_output_stream_get_etag(stream: *mut GFileOutputStream) -> *mut gchar;
    pub fn g_file_output_stream_query_info(stream: *mut GFileOutputStream, attributes: *const gchar, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_output_stream_query_info_async(stream: *mut GFileOutputStream, attributes: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_output_stream_query_info_finish(stream: *mut GFileOutputStream, result: *mut GAsyncResult) -> *mut GFileInfo;
    pub fn g_file_parse_name(parse_name: *const gchar) -> *mut GFile;
    pub fn g_file_poll_mountable(file: *mut GFile, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_poll_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_query_default_handler(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GAppInfo;
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_query_file_type(file: *mut GFile, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> GFileType;
    pub fn g_file_query_filesystem_info(file: *mut GFile, attributes: *const gchar, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_query_filesystem_info_async(file: *mut GFile, attributes: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_query_filesystem_info_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileInfo;
    pub fn g_file_query_info(file: *mut GFile, attributes: *const gchar, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> *mut GFileInfo;
    pub fn g_file_query_info_async(file: *mut GFile, attributes: *const gchar, flags: GFileQueryInfoFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_query_info_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileInfo;
    pub fn g_file_query_settable_attributes(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GFileAttributeInfoList;
    pub fn g_file_query_writable_namespaces(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GFileAttributeInfoList;
    pub fn g_file_read(file: *mut GFile, cancellable: *mut GCancellable) -> *mut GFileInputStream;
    pub fn g_file_read_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_read_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileInputStream;
    pub fn g_file_replace(file: *mut GFile, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable) -> *mut GFileOutputStream;
    pub fn g_file_replace_async(file: *mut GFile, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_replace_contents(file: *mut GFile, contents: *mut u8, length: gsize, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, new_etag: *mut *mut gchar, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_replace_contents_async(file: *mut GFile, contents: *mut u8, length: gsize, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_replace_contents_bytes_async(file: *mut GFile, contents: *mut glib::GBytes, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_replace_contents_finish(file: *mut GFile, res: *mut GAsyncResult, new_etag: *mut *mut gchar) -> gboolean;
    pub fn g_file_replace_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileOutputStream;
    pub fn g_file_replace_readwrite(file: *mut GFile, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, cancellable: *mut GCancellable) -> *mut GFileIOStream;
    pub fn g_file_replace_readwrite_async(file: *mut GFile, etag: *const gchar, make_backup: gboolean, flags: GFileCreateFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_replace_readwrite_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFileIOStream;
    pub fn g_file_resolve_relative_path(file: *mut GFile, relative_path: *const gchar) -> *mut GFile;
    pub fn g_file_set_attribute(file: *mut GFile, attribute: *const gchar, type_: GFileAttributeType, value_p: gpointer, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_byte_string(file: *mut GFile, attribute: *const gchar, value: *const gchar, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_int32(file: *mut GFile, attribute: *const gchar, value: i32, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_int64(file: *mut GFile, attribute: *const gchar, value: i64, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_string(file: *mut GFile, attribute: *const gchar, value: *const gchar, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_uint32(file: *mut GFile, attribute: *const gchar, value: u32, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attribute_uint64(file: *mut GFile, attribute: *const gchar, value: u64, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_attributes_async(file: *mut GFile, info: *mut GFileInfo, flags: GFileQueryInfoFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_set_attributes_finish(file: *mut GFile, result: *mut GAsyncResult, info: *mut *mut GFileInfo) -> gboolean;
    pub fn g_file_set_attributes_from_info(file: *mut GFile, info: *mut GFileInfo, flags: GFileQueryInfoFlags, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_set_display_name(file: *mut GFile, display_name: *const gchar, cancellable: *mut GCancellable) -> *mut GFile;
    pub fn g_file_set_display_name_async(file: *mut GFile, display_name: *const gchar, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_set_display_name_finish(file: *mut GFile, res: *mut GAsyncResult) -> *mut GFile;
    pub fn g_file_start_mountable(file: *mut GFile, flags: GDriveStartFlags, start_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_start_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_stop_mountable(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_stop_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
    pub fn g_file_trash(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_trash_async(file: *mut GFile, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_trash_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_unmount_mountable(file: *mut GFile, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_unmount_mountable_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_file_unmount_mountable_with_operation(file: *mut GFile, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_file_unmount_mountable_with_operation_finish(file: *mut GFile, result: *mut GAsyncResult) -> gboolean;
    pub fn g_filename_completer_get_completion_suffix(completer: *mut GFilenameCompleter, initial_text: *const gchar) -> *mut gchar;
    pub fn g_filename_completer_get_completions(completer: *mut GFilenameCompleter, initial_text: *const gchar) -> *mut *mut gchar;
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
    pub fn g_filename_completer_set_dirs_only(completer: *mut GFilenameCompleter, dirs_only: gboolean);
    pub fn g_filter_input_stream_get_base_stream(stream: *mut GFilterInputStream) -> *mut GInputStream;
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream) -> gboolean;
    pub fn g_filter_input_stream_set_close_base_stream(stream: *mut GFilterInputStream, close_base: gboolean);
    pub fn g_filter_output_stream_get_base_stream(stream: *mut GFilterOutputStream) -> *mut GOutputStream;
    pub fn g_filter_output_stream_get_close_base_stream(stream: *mut GFilterOutputStream) -> gboolean;
    pub fn g_filter_output_stream_set_close_base_stream(stream: *mut GFilterOutputStream, close_base: gboolean);
    pub fn g_icon_deserialize(value: *mut glib::GVariant) -> *mut GIcon;
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
    pub fn g_icon_new_for_string(str: *const gchar) -> *mut GIcon;
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut glib::GVariant;
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
    pub fn g_inet_address_equal(address: *mut GInetAddress, other_address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> gsize;
    pub fn g_inet_address_mask_equal(mask: *mut GInetAddressMask, mask2: *mut GInetAddressMask) -> gboolean;
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> guint;
    pub fn g_inet_address_mask_matches(mask: *mut GInetAddressMask, address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_mask_new(addr: *mut GInetAddress, length: guint) -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_new_from_string(mask_string: *const gchar) -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut gchar;
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_new_from_bytes(bytes: *mut u8, family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_new_from_string(string: *const gchar) -> *mut GInetAddress;
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> u8;
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress) -> *mut GInetAddress;
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> u32;
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> u16;
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> u32;
    pub fn g_inet_socket_address_new(address: *mut GInetAddress, port: u16) -> *mut GSocketAddress;
    pub fn g_inet_socket_address_new_from_string(address: *const gchar, port: guint) -> *mut GSocketAddress;
    pub fn g_initable_init(initable: *mut GInitable, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_initable_new(object_type: GType, cancellable: *mut GCancellable, error: *mut *mut glib::GError, first_property_name: *const gchar, ...) -> gpointer;
    pub fn g_initable_newv(object_type: GType, n_parameters: guint, parameters: *mut gobject::GParameter, cancellable: *mut GCancellable) -> gpointer;
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
    pub fn g_input_stream_close(stream: *mut GInputStream, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_input_stream_close_async(stream: *mut GInputStream, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_input_stream_close_finish(stream: *mut GInputStream, result: *mut GAsyncResult) -> gboolean;
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_read(stream: *mut GInputStream, buffer: *mut u8, count: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_input_stream_read_all(stream: *mut GInputStream, buffer: *mut u8, count: gsize, bytes_read: *mut gsize, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_input_stream_read_all_async(stream: *mut GInputStream, buffer: *mut u8, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_input_stream_read_all_finish(stream: *mut GInputStream, result: *mut GAsyncResult, bytes_read: *mut gsize) -> gboolean;
    pub fn g_input_stream_read_async(stream: *mut GInputStream, buffer: *mut u8, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_input_stream_read_bytes(stream: *mut GInputStream, count: gsize, cancellable: *mut GCancellable) -> *mut glib::GBytes;
    pub fn g_input_stream_read_bytes_async(stream: *mut GInputStream, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_input_stream_read_bytes_finish(stream: *mut GInputStream, result: *mut GAsyncResult) -> *mut glib::GBytes;
    pub fn g_input_stream_read_finish(stream: *mut GInputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_input_stream_set_pending(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_skip(stream: *mut GInputStream, count: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_input_stream_skip_async(stream: *mut GInputStream, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_input_stream_skip_finish(stream: *mut GInputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
    pub fn g_io_error_quark() -> glib::GQuark;
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const gchar;
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
    pub fn g_io_extension_point_get_extension_by_name(extension_point: *mut GIOExtensionPoint, name: *const gchar) -> *mut GIOExtension;
    pub fn g_io_extension_point_get_extensions(extension_point: *mut GIOExtensionPoint) -> *mut glib::GList;
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint) -> GType;
    pub fn g_io_extension_point_implement(extension_point_name: *const gchar, type_: GType, extension_name: *const gchar, priority: gint) -> *mut GIOExtension;
    pub fn g_io_extension_point_lookup(name: *const gchar) -> *mut GIOExtensionPoint;
    pub fn g_io_extension_point_register(name: *const gchar) -> *mut GIOExtensionPoint;
    pub fn g_io_extension_point_set_required_type(extension_point: *mut GIOExtensionPoint, type_: GType);
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut gobject::GTypeClass;
    pub fn g_io_module_load(module: *mut GIOModule);
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
    pub fn g_io_module_query() -> *mut *mut gchar;
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const gchar);
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;
    pub fn g_io_module_unload(module: *mut GIOModule);
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar) -> *mut glib::GList;
    pub fn g_io_modules_load_all_in_directory_with_scope(dirname: *const gchar, scope: *mut GIOModuleScope) -> *mut glib::GList;
    pub fn g_io_modules_scan_all_in_directory(dirname: *const gchar);
    pub fn g_io_modules_scan_all_in_directory_with_scope(dirname: *const gchar, scope: *mut GIOModuleScope);
    pub fn g_io_scheduler_cancel_all_jobs();
    pub fn g_io_scheduler_job_send_to_mainloop(job: *mut GIOSchedulerJob, func: glib::GSourceFunc, user_data: gpointer, notify: Option<glib::GDestroyNotify>) -> gboolean;
    pub fn g_io_scheduler_job_send_to_mainloop_async(job: *mut GIOSchedulerJob, func: glib::GSourceFunc, user_data: gpointer, notify: Option<glib::GDestroyNotify>);
    pub fn g_io_scheduler_push_job(job_func: GIOSchedulerJobFunc, user_data: gpointer, notify: Option<glib::GDestroyNotify>, io_priority: gint, cancellable: *mut GCancellable);
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
    pub fn g_io_stream_close(stream: *mut GIOStream, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_io_stream_close_async(stream: *mut GIOStream, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_io_stream_close_finish(stream: *mut GIOStream, result: *mut GAsyncResult) -> gboolean;
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_set_pending(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_splice_async(stream1: *mut GIOStream, stream2: *mut GIOStream, flags: GIOStreamSpliceFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_io_stream_splice_finish(result: *mut GAsyncResult) -> gboolean;
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint) -> gpointer;
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint) -> *mut gobject::GObject;
    pub fn g_list_model_items_changed(list: *mut GListModel, position: guint, removed: guint, added: guint);
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
    pub fn g_list_store_insert(store: *mut GListStore, position: guint, item: gpointer);
    pub fn g_list_store_insert_sorted(store: *mut GListStore, item: gpointer, compare_func: glib::GCompareDataFunc, user_data: gpointer) -> guint;
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
    pub fn g_list_store_remove_all(store: *mut GListStore);
    pub fn g_list_store_sort(store: *mut GListStore, compare_func: glib::GCompareDataFunc, user_data: gpointer);
    pub fn g_list_store_splice(store: *mut GListStore, position: guint, n_removals: guint, additions: *mut gpointer, n_additions: guint);
    pub fn g_loadable_icon_load(icon: *mut GLoadableIcon, size: gint, type_: *mut *mut gchar, cancellable: *mut GCancellable) -> *mut GInputStream;
    pub fn g_loadable_icon_load_async(icon: *mut GLoadableIcon, size: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_loadable_icon_load_finish(icon: *mut GLoadableIcon, res: *mut GAsyncResult, type_: *mut *mut gchar) -> *mut GInputStream;
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut glib::GBytes);
    pub fn g_memory_input_stream_add_data(stream: *mut GMemoryInputStream, data: *mut u8, len: gssize, destroy: Option<glib::GDestroyNotify>);
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut glib::GBytes) -> *mut GInputStream;
    pub fn g_memory_input_stream_new_from_data(data: *mut u8, len: gssize, destroy: Option<glib::GDestroyNotify>) -> *mut GInputStream;
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> gsize;
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> gsize;
    pub fn g_memory_output_stream_new(data: gpointer, size: gsize, realloc_function: Option<GReallocFunc>, destroy_function: Option<glib::GDestroyNotify>) -> *mut GOutputStream;
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut glib::GBytes;
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const gchar;
    pub fn g_menu_attribute_iter_get_next(iter: *mut GMenuAttributeIter, out_name: *mut *const gchar, value: *mut *mut glib::GVariant) -> gboolean;
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut glib::GVariant;
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;
    pub fn g_menu_freeze(menu: *mut GMenu);
    pub fn g_menu_insert(menu: *mut GMenu, position: gint, label: *const gchar, detailed_action: *const gchar);
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint, item: *mut GMenuItem);
    pub fn g_menu_insert_section(menu: *mut GMenu, position: gint, label: *const gchar, section: *mut GMenuModel);
    pub fn g_menu_insert_submenu(menu: *mut GMenu, position: gint, label: *const gchar, submenu: *mut GMenuModel);
    pub fn g_menu_item_get_attribute(menu_item: *mut GMenuItem, attribute: *const gchar, format_string: *const gchar, ...) -> gboolean;
    pub fn g_menu_item_get_attribute_value(menu_item: *mut GMenuItem, attribute: *const gchar, expected_type: *const glib::GVariantType) -> *mut glib::GVariant;
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar) -> *mut GMenuModel;
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar) -> *mut GMenuItem;
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: gint) -> *mut GMenuItem;
    pub fn g_menu_item_new_section(label: *const gchar, section: *mut GMenuModel) -> *mut GMenuItem;
    pub fn g_menu_item_new_submenu(label: *const gchar, submenu: *mut GMenuModel) -> *mut GMenuItem;
    pub fn g_menu_item_set_action_and_target(menu_item: *mut GMenuItem, action: *const gchar, format_string: *const gchar, ...);
    pub fn g_menu_item_set_action_and_target_value(menu_item: *mut GMenuItem, action: *const gchar, target_value: *mut glib::GVariant);
    pub fn g_menu_item_set_attribute(menu_item: *mut GMenuItem, attribute: *const gchar, format_string: *const gchar, ...);
    pub fn g_menu_item_set_attribute_value(menu_item: *mut GMenuItem, attribute: *const gchar, value: *mut glib::GVariant);
    pub fn g_menu_item_set_detailed_action(menu_item: *mut GMenuItem, detailed_action: *const gchar);
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const gchar);
    pub fn g_menu_item_set_link(menu_item: *mut GMenuItem, link: *const gchar, model: *mut GMenuModel);
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const gchar;
    pub fn g_menu_link_iter_get_next(iter: *mut GMenuLinkIter, out_link: *mut *const gchar, value: *mut *mut GMenuModel) -> gboolean;
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
    pub fn g_menu_model_get_item_attribute(model: *mut GMenuModel, item_index: gint, attribute: *const gchar, format_string: *const gchar, ...) -> gboolean;
    pub fn g_menu_model_get_item_attribute_value(model: *mut GMenuModel, item_index: gint, attribute: *const gchar, expected_type: *const glib::GVariantType) -> *mut glib::GVariant;
    pub fn g_menu_model_get_item_link(model: *mut GMenuModel, item_index: gint, link: *const gchar) -> *mut GMenuModel;
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
    pub fn g_menu_model_items_changed(model: *mut GMenuModel, position: gint, removed: gint, added: gint);
    pub fn g_menu_model_iterate_item_attributes(model: *mut GMenuModel, item_index: gint) -> *mut GMenuAttributeIter;
    pub fn g_menu_model_iterate_item_links(model: *mut GMenuModel, item_index: gint) -> *mut GMenuLinkIter;
    pub fn g_menu_new() -> *mut GMenu;
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
    pub fn g_menu_remove_all(menu: *mut GMenu);
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
    pub fn g_mount_eject(mount: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_eject_finish(mount: *mut GMount, result: *mut GAsyncResult) -> gboolean;
    pub fn g_mount_eject_with_operation(mount: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_eject_with_operation_finish(mount: *mut GMount, result: *mut GAsyncResult) -> gboolean;
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut gchar;
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut gchar;
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
    pub fn g_mount_guess_content_type(mount: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_guess_content_type_finish(mount: *mut GMount, result: *mut GAsyncResult) -> *mut *mut gchar;
    pub fn g_mount_guess_content_type_sync(mount: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable) -> *mut *mut gchar;
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> gint;
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const gchar;
    pub fn g_mount_operation_get_password(op: *mut GMountOperation) -> *const gchar;
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
    pub fn g_mount_operation_get_username(op: *mut GMountOperation) -> *const gchar;
    pub fn g_mount_operation_new() -> *mut GMountOperation;
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: gint);
    pub fn g_mount_operation_set_domain(op: *mut GMountOperation, domain: *const gchar);
    pub fn g_mount_operation_set_password(op: *mut GMountOperation, password: *const gchar);
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
    pub fn g_mount_operation_set_username(op: *mut GMountOperation, username: *const gchar);
    pub fn g_mount_remount(mount: *mut GMount, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_remount_finish(mount: *mut GMount, result: *mut GAsyncResult) -> gboolean;
    pub fn g_mount_shadow(mount: *mut GMount);
    pub fn g_mount_unmount(mount: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_unmount_finish(mount: *mut GMount, result: *mut GAsyncResult) -> gboolean;
    pub fn g_mount_unmount_with_operation(mount: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_mount_unmount_with_operation_finish(mount: *mut GMount, result: *mut GAsyncResult) -> gboolean;
    pub fn g_mount_unshadow(mount: *mut GMount);
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const gchar;
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> u16;
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const gchar;
    pub fn g_network_address_new(hostname: *const gchar, port: u16) -> *mut GSocketConnectable;
    pub fn g_network_address_new_loopback(port: u16) -> *mut GSocketConnectable;
    pub fn g_network_address_parse(host_and_port: *const gchar, default_port: u16) -> *mut GSocketConnectable;
    pub fn g_network_address_parse_uri(uri: *const gchar, default_port: u16) -> *mut GSocketConnectable;
    pub fn g_network_monitor_can_reach(monitor: *mut GNetworkMonitor, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_network_monitor_can_reach_async(monitor: *mut GNetworkMonitor, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_network_monitor_can_reach_finish(monitor: *mut GNetworkMonitor, result: *mut GAsyncResult) -> gboolean;
    pub fn g_network_monitor_get_connectivity(monitor: *mut GNetworkMonitor) -> GNetworkConnectivity;
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const gchar;
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const gchar;
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const gchar;
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const gchar;
    pub fn g_network_service_new(service: *const gchar, protocol: *const gchar, domain: *const gchar) -> *mut GSocketConnectable;
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const gchar);
    pub fn g_networking_init();
    pub fn g_notification_add_button(notification: *mut GNotification, label: *const gchar, detailed_action: *const gchar);
    pub fn g_notification_add_button_with_target(notification: *mut GNotification, label: *const gchar, action: *const gchar, target_format: *const gchar, ...);
    pub fn g_notification_add_button_with_target_value(notification: *mut GNotification, label: *const gchar, action: *const gchar, target: *mut glib::GVariant);
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const gchar);
    pub fn g_notification_set_default_action(notification: *mut GNotification, detailed_action: *const gchar);
    pub fn g_notification_set_default_action_and_target(notification: *mut GNotification, action: *const gchar, target_format: *const gchar, ...);
    pub fn g_notification_set_default_action_and_target_value(notification: *mut GNotification, action: *const gchar, target: *mut glib::GVariant);
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
    pub fn g_notification_set_priority(notification: *mut GNotification, priority: GNotificationPriority);
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const gchar);
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
    pub fn g_output_stream_close(stream: *mut GOutputStream, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_output_stream_close_async(stream: *mut GOutputStream, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_close_finish(stream: *mut GOutputStream, result: *mut GAsyncResult) -> gboolean;
    pub fn g_output_stream_flush(stream: *mut GOutputStream, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_output_stream_flush_async(stream: *mut GOutputStream, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_flush_finish(stream: *mut GOutputStream, result: *mut GAsyncResult) -> gboolean;
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_printf(stream: *mut GOutputStream, bytes_written: *mut gsize, cancellable: *mut GCancellable, error: *mut *mut glib::GError, format: *const gchar, ...) -> gboolean;
    pub fn g_output_stream_set_pending(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_splice(stream: *mut GOutputStream, source: *mut GInputStream, flags: GOutputStreamSpliceFlags, cancellable: *mut GCancellable) -> gssize;
    pub fn g_output_stream_splice_async(stream: *mut GOutputStream, source: *mut GInputStream, flags: GOutputStreamSpliceFlags, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_splice_finish(stream: *mut GOutputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_output_stream_write(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_output_stream_write_all(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, bytes_written: *mut gsize, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_output_stream_write_all_async(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_write_all_finish(stream: *mut GOutputStream, result: *mut GAsyncResult, bytes_written: *mut gsize) -> gboolean;
    pub fn g_output_stream_write_async(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_write_bytes(stream: *mut GOutputStream, bytes: *mut glib::GBytes, cancellable: *mut GCancellable) -> gssize;
    pub fn g_output_stream_write_bytes_async(stream: *mut GOutputStream, bytes: *mut glib::GBytes, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_output_stream_write_bytes_finish(stream: *mut GOutputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_output_stream_write_finish(stream: *mut GOutputStream, result: *mut GAsyncResult) -> gssize;
    pub fn g_permission_acquire(permission: *mut GPermission, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_permission_acquire_async(permission: *mut GPermission, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_permission_acquire_finish(permission: *mut GPermission, result: *mut GAsyncResult) -> gboolean;
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_impl_update(permission: *mut GPermission, allowed: gboolean, can_acquire: gboolean, can_release: gboolean);
    pub fn g_permission_release(permission: *mut GPermission, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_permission_release_async(permission: *mut GPermission, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_permission_release_finish(permission: *mut GPermission, result: *mut GAsyncResult) -> gboolean;
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
    pub fn g_pollable_input_stream_create_source(stream: *mut GPollableInputStream, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
    pub fn g_pollable_input_stream_read_nonblocking(stream: *mut GPollableInputStream, buffer: *mut u8, count: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
    pub fn g_pollable_output_stream_create_source(stream: *mut GPollableOutputStream, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
    pub fn g_pollable_output_stream_write_nonblocking(stream: *mut GPollableOutputStream, buffer: *mut u8, count: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_pollable_source_new(pollable_stream: *mut gobject::GObject) -> *mut glib::GSource;
    pub fn g_pollable_source_new_full(pollable_stream: gpointer, child_source: *mut glib::GSource, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_pollable_stream_read(stream: *mut GInputStream, buffer: *mut u8, count: gsize, blocking: gboolean, cancellable: *mut GCancellable) -> gssize;
    pub fn g_pollable_stream_write(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, blocking: gboolean, cancellable: *mut GCancellable) -> gssize;
    pub fn g_pollable_stream_write_all(stream: *mut GOutputStream, buffer: *mut u8, count: gsize, blocking: gboolean, bytes_written: *mut gsize, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_property_action_new(name: *const gchar, object: gpointer, property_name: *const gchar) -> *mut GPropertyAction;
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> u16;
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_proxy_address_new(inetaddr: *mut GInetAddress, port: u16, protocol: *const gchar, dest_hostname: *const gchar, dest_port: u16, username: *const gchar, password: *const gchar) -> *mut GSocketAddress;
    pub fn g_proxy_connect(proxy: *mut GProxy, connection: *mut GIOStream, proxy_address: *mut GProxyAddress, cancellable: *mut GCancellable) -> *mut GIOStream;
    pub fn g_proxy_connect_async(proxy: *mut GProxy, connection: *mut GIOStream, proxy_address: *mut GProxyAddress, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_proxy_connect_finish(proxy: *mut GProxy, result: *mut GAsyncResult) -> *mut GIOStream;
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar) -> *mut GProxy;
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
    pub fn g_proxy_resolver_lookup(resolver: *mut GProxyResolver, uri: *const gchar, cancellable: *mut GCancellable) -> *mut *mut gchar;
    pub fn g_proxy_resolver_lookup_async(resolver: *mut GProxyResolver, uri: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_proxy_resolver_lookup_finish(resolver: *mut GProxyResolver, result: *mut GAsyncResult) -> *mut *mut gchar;
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
    pub fn g_remote_action_group_activate_action_full(remote: *mut GRemoteActionGroup, action_name: *const gchar, parameter: *mut glib::GVariant, platform_data: *mut glib::GVariant);
    pub fn g_remote_action_group_change_action_state_full(remote: *mut GRemoteActionGroup, action_name: *const gchar, value: *mut glib::GVariant, platform_data: *mut glib::GVariant);
    pub fn g_resolver_error_quark() -> glib::GQuark;
    pub fn g_resolver_free_addresses(addresses: *mut glib::GList);
    pub fn g_resolver_free_targets(targets: *mut glib::GList);
    pub fn g_resolver_get_default() -> *mut GResolver;
    pub fn g_resolver_lookup_by_address(resolver: *mut GResolver, address: *mut GInetAddress, cancellable: *mut GCancellable) -> *mut gchar;
    pub fn g_resolver_lookup_by_address_async(resolver: *mut GResolver, address: *mut GInetAddress, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_resolver_lookup_by_address_finish(resolver: *mut GResolver, result: *mut GAsyncResult) -> *mut gchar;
    pub fn g_resolver_lookup_by_name(resolver: *mut GResolver, hostname: *const gchar, cancellable: *mut GCancellable) -> *mut glib::GList;
    pub fn g_resolver_lookup_by_name_async(resolver: *mut GResolver, hostname: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_resolver_lookup_by_name_finish(resolver: *mut GResolver, result: *mut GAsyncResult) -> *mut glib::GList;
    pub fn g_resolver_lookup_records(resolver: *mut GResolver, rrname: *const gchar, record_type: GResolverRecordType, cancellable: *mut GCancellable) -> *mut glib::GList;
    pub fn g_resolver_lookup_records_async(resolver: *mut GResolver, rrname: *const gchar, record_type: GResolverRecordType, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_resolver_lookup_records_finish(resolver: *mut GResolver, result: *mut GAsyncResult) -> *mut glib::GList;
    pub fn g_resolver_lookup_service(resolver: *mut GResolver, service: *const gchar, protocol: *const gchar, domain: *const gchar, cancellable: *mut GCancellable) -> *mut glib::GList;
    pub fn g_resolver_lookup_service_async(resolver: *mut GResolver, service: *const gchar, protocol: *const gchar, domain: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_resolver_lookup_service_finish(resolver: *mut GResolver, result: *mut GAsyncResult) -> *mut glib::GList;
    pub fn g_resolver_set_default(resolver: *mut GResolver);
    pub fn g_resource_enumerate_children(resource: *mut GResource, path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut *mut gchar;
    pub fn g_resource_error_quark() -> glib::GQuark;
    pub fn g_resource_get_info(resource: *mut GResource, path: *const gchar, lookup_flags: GResourceLookupFlags, size: *mut gsize, flags: *mut u32) -> gboolean;
    pub fn g_resource_load(filename: *mut gchar) -> *mut GResource;
    pub fn g_resource_lookup_data(resource: *mut GResource, path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut glib::GBytes;
    pub fn g_resource_new_from_data(data: *mut glib::GBytes) -> *mut GResource;
    pub fn g_resource_open_stream(resource: *mut GResource, path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut GInputStream;
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
    pub fn g_resource_unref(resource: *mut GResource);
    pub fn g_resources_enumerate_children(path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut *mut gchar;
    pub fn g_resources_get_info(path: *const gchar, lookup_flags: GResourceLookupFlags, size: *mut gsize, flags: *mut u32) -> gboolean;
    pub fn g_resources_lookup_data(path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut glib::GBytes;
    pub fn g_resources_open_stream(path: *const gchar, lookup_flags: GResourceLookupFlags) -> *mut GInputStream;
    pub fn g_resources_register(resource: *mut GResource);
    pub fn g_resources_unregister(resource: *mut GResource);
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_seek(seekable: *mut GSeekable, offset: i64, type_: glib::GSeekType, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> i64;
    pub fn g_seekable_truncate(seekable: *mut GSeekable, offset: i64, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_settings_apply(settings: *mut GSettings);
    pub fn g_settings_bind(settings: *mut GSettings, key: *const gchar, object: gpointer, property: *const gchar, flags: GSettingsBindFlags);
    pub fn g_settings_bind_with_mapping(settings: *mut GSettings, key: *const gchar, object: gpointer, property: *const gchar, flags: GSettingsBindFlags, get_mapping: GSettingsBindGetMapping, set_mapping: GSettingsBindSetMapping, user_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn g_settings_bind_writable(settings: *mut GSettings, key: *const gchar, object: gpointer, property: *const gchar, inverted: gboolean);
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const gchar) -> *mut GAction;
    pub fn g_settings_delay(settings: *mut GSettings);
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...);
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar) -> gboolean;
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar) -> *mut GSettings;
    pub fn g_settings_get_default_value(settings: *mut GSettings, key: *const gchar) -> *mut glib::GVariant;
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar) -> gdouble;
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar) -> gint;
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar) -> guint;
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar) -> gint;
    pub fn g_settings_get_mapped(settings: *mut GSettings, key: *const gchar, mapping: GSettingsGetMapping, user_data: gpointer) -> gpointer;
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar) -> *mut glib::GVariant;
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar) -> *mut gchar;
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar) -> *mut *mut gchar;
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar) -> guint;
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const gchar) -> *mut glib::GVariant;
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar) -> *mut glib::GVariant;
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const gchar) -> gboolean;
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut gchar;
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
    pub fn g_settings_list_schemas() -> *const *const gchar;
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
    pub fn g_settings_new_full(schema: *mut GSettingsSchema, backend: *mut GSettingsBackend, path: *const gchar) -> *mut GSettings;
    pub fn g_settings_new_with_backend(schema_id: *const gchar, backend: *mut GSettingsBackend) -> *mut GSettings;
    pub fn g_settings_new_with_backend_and_path(schema_id: *const gchar, backend: *mut GSettingsBackend, path: *const gchar) -> *mut GSettings;
    pub fn g_settings_new_with_path(schema_id: *const gchar, path: *const gchar) -> *mut GSettings;
    pub fn g_settings_range_check(settings: *mut GSettings, key: *const gchar, value: *mut glib::GVariant) -> gboolean;
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
    pub fn g_settings_revert(settings: *mut GSettings);
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const gchar;
    pub fn g_settings_schema_get_key(schema: *mut GSettingsSchema, name: *const gchar) -> *mut GSettingsSchemaKey;
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const gchar;
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const gchar) -> gboolean;
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut glib::GVariant;
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const gchar;
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const gchar;
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut glib::GVariant;
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const gchar;
    pub fn g_settings_schema_key_get_value_type(key: *mut GSettingsSchemaKey) -> *const glib::GVariantType;
    pub fn g_settings_schema_key_range_check(key: *mut GSettingsSchemaKey, value: *mut glib::GVariant) -> gboolean;
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut gchar;
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut gchar;
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_list_schemas(source: *mut GSettingsSchemaSource, recursive: gboolean, non_relocatable: *mut *mut *mut gchar, relocatable: *mut *mut *mut gchar);
    pub fn g_settings_schema_source_lookup(source: *mut GSettingsSchemaSource, schema_id: *const gchar, recursive: gboolean) -> *mut GSettingsSchema;
    pub fn g_settings_schema_source_new_from_directory(directory: *const gchar, parent: *mut GSettingsSchemaSource, trusted: gboolean) -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_ref(source: *mut GSettingsSchemaSource) -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
    pub fn g_settings_set(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...) -> gboolean;
    pub fn g_settings_set_boolean(settings: *mut GSettings, key: *const gchar, value: gboolean) -> gboolean;
    pub fn g_settings_set_double(settings: *mut GSettings, key: *const gchar, value: gdouble) -> gboolean;
    pub fn g_settings_set_enum(settings: *mut GSettings, key: *const gchar, value: gint) -> gboolean;
    pub fn g_settings_set_flags(settings: *mut GSettings, key: *const gchar, value: guint) -> gboolean;
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar, value: gint) -> gboolean;
    pub fn g_settings_set_string(settings: *mut GSettings, key: *const gchar, value: *const gchar) -> gboolean;
    pub fn g_settings_set_strv(settings: *mut GSettings, key: *const gchar, value: *mut *mut gchar) -> gboolean;
    pub fn g_settings_set_uint(settings: *mut GSettings, key: *const gchar, value: guint) -> gboolean;
    pub fn g_settings_set_value(settings: *mut GSettings, key: *const gchar, value: *mut glib::GVariant) -> gboolean;
    pub fn g_settings_sync();
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
    pub fn g_simple_action_group_add_entries(simple: *mut GSimpleActionGroup, entries: *mut GActionEntry, n_entries: gint, user_data: gpointer);
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
    pub fn g_simple_action_group_lookup(simple: *mut GSimpleActionGroup, action_name: *const gchar) -> *mut GAction;
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const gchar);
    pub fn g_simple_action_new(name: *const gchar, parameter_type: *const glib::GVariantType) -> *mut GSimpleAction;
    pub fn g_simple_action_new_stateful(name: *const gchar, parameter_type: *const glib::GVariantType, state: *mut glib::GVariant) -> *mut GSimpleAction;
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut glib::GVariant);
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut glib::GVariant);
    pub fn g_simple_async_report_error_in_idle(object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, domain: glib::GQuark, code: gint, format: *const gchar, ...);
    pub fn g_simple_async_report_gerror_in_idle(object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, error: *const glib::GError);
    pub fn g_simple_async_report_take_gerror_in_idle(object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, error: *mut glib::GError);
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> gssize;
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
    pub fn g_simple_async_result_is_valid(result: *mut GAsyncResult, source: *mut gobject::GObject, source_tag: gpointer) -> gboolean;
    pub fn g_simple_async_result_new(source_object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, source_tag: gpointer) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_error(source_object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, domain: glib::GQuark, code: gint, format: *const gchar, ...) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_from_error(source_object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, error: *const glib::GError) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_take_error(source_object: *mut gobject::GObject, callback: Option<GAsyncReadyCallback>, user_data: gpointer, error: *mut glib::GError) -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_propagate_error(simple: *mut GSimpleAsyncResult) -> gboolean;
    pub fn g_simple_async_result_run_in_thread(simple: *mut GSimpleAsyncResult, func: GSimpleAsyncThreadFunc, io_priority: gint, cancellable: *mut GCancellable);
    pub fn g_simple_async_result_set_check_cancellable(simple: *mut GSimpleAsyncResult, check_cancellable: *mut GCancellable);
    pub fn g_simple_async_result_set_error(simple: *mut GSimpleAsyncResult, domain: glib::GQuark, code: gint, format: *const gchar, ...);
    pub fn g_simple_async_result_set_from_error(simple: *mut GSimpleAsyncResult, error: *const glib::GError);
    pub fn g_simple_async_result_set_handle_cancellation(simple: *mut GSimpleAsyncResult, handle_cancellation: gboolean);
    pub fn g_simple_async_result_set_op_res_gboolean(simple: *mut GSimpleAsyncResult, op_res: gboolean);
    pub fn g_simple_async_result_set_op_res_gpointer(simple: *mut GSimpleAsyncResult, op_res: gpointer, destroy_op_res: glib::GDestroyNotify);
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: gssize);
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut glib::GError);
    pub fn g_simple_io_stream_new(input_stream: *mut GInputStream, output_stream: *mut GOutputStream) -> *mut GIOStream;
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
    pub fn g_simple_proxy_resolver_new(default_proxy: *const gchar, ignore_hosts: *mut *mut gchar) -> *mut GProxyResolver;
    pub fn g_simple_proxy_resolver_set_default_proxy(resolver: *mut GSimpleProxyResolver, default_proxy: *const gchar);
    pub fn g_simple_proxy_resolver_set_ignore_hosts(resolver: *mut GSimpleProxyResolver, ignore_hosts: *mut *mut gchar);
    pub fn g_simple_proxy_resolver_set_uri_proxy(resolver: *mut GSimpleProxyResolver, uri_scheme: *const gchar, proxy: *const gchar);
    pub fn g_socket_accept(socket: *mut GSocket, cancellable: *mut GCancellable) -> *mut GSocket;
    pub fn g_socket_address_enumerator_next(enumerator: *mut GSocketAddressEnumerator, cancellable: *mut GCancellable) -> *mut GSocketAddress;
    pub fn g_socket_address_enumerator_next_async(enumerator: *mut GSocketAddressEnumerator, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_address_enumerator_next_finish(enumerator: *mut GSocketAddressEnumerator, result: *mut GAsyncResult) -> *mut GSocketAddress;
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> gssize;
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize) -> *mut GSocketAddress;
    pub fn g_socket_address_to_native(address: *mut GSocketAddress, dest: gpointer, destlen: gsize) -> gboolean;
    pub fn g_socket_bind(socket: *mut GSocket, address: *mut GSocketAddress, allow_reuse: gboolean) -> gboolean;
    pub fn g_socket_check_connect_result(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_client_add_application_proxy(client: *mut GSocketClient, protocol: *const gchar);
    pub fn g_socket_client_connect(client: *mut GSocketClient, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_async(client: *mut GSocketClient, connectable: *mut GSocketConnectable, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_client_connect_finish(client: *mut GSocketClient, result: *mut GAsyncResult) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host(client: *mut GSocketClient, host_and_port: *const gchar, default_port: u16, cancellable: *mut GCancellable) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host_async(client: *mut GSocketClient, host_and_port: *const gchar, default_port: u16, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_client_connect_to_host_finish(client: *mut GSocketClient, result: *mut GAsyncResult) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service(client: *mut GSocketClient, domain: *const gchar, service: *const gchar, cancellable: *mut GCancellable) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service_async(client: *mut GSocketClient, domain: *const gchar, service: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_client_connect_to_service_finish(client: *mut GSocketClient, result: *mut GAsyncResult) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri(client: *mut GSocketClient, uri: *const gchar, default_port: u16, cancellable: *mut GCancellable) -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri_async(client: *mut GSocketClient, uri: *const gchar, default_port: u16, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_client_connect_to_uri_finish(client: *mut GSocketClient, result: *mut GAsyncResult) -> *mut GSocketConnection;
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
    pub fn g_socket_client_get_tls_validation_flags(client: *mut GSocketClient) -> GTlsCertificateFlags;
    pub fn g_socket_client_new() -> *mut GSocketClient;
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
    pub fn g_socket_client_set_local_address(client: *mut GSocketClient, address: *mut GSocketAddress);
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
    pub fn g_socket_client_set_proxy_resolver(client: *mut GSocketClient, proxy_resolver: *mut GProxyResolver);
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: guint);
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
    pub fn g_socket_client_set_tls_validation_flags(client: *mut GSocketClient, flags: GTlsCertificateFlags);
    pub fn g_socket_close(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: glib::GIOCondition) -> glib::GIOCondition;
    pub fn g_socket_condition_timed_wait(socket: *mut GSocket, condition: glib::GIOCondition, timeout: i64, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_socket_condition_wait(socket: *mut GSocket, condition: glib::GIOCondition, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_socket_connect(socket: *mut GSocket, address: *mut GSocketAddress, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_socket_connectable_enumerate(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator;
    pub fn g_socket_connectable_proxy_enumerate(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator;
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut gchar;
    pub fn g_socket_connection_connect(connection: *mut GSocketConnection, address: *mut GSocketAddress, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_socket_connection_connect_async(connection: *mut GSocketConnection, address: *mut GSocketAddress, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_connection_connect_finish(connection: *mut GSocketConnection, result: *mut GAsyncResult) -> gboolean;
    pub fn g_socket_connection_factory_create_connection(socket: *mut GSocket) -> *mut GSocketConnection;
    pub fn g_socket_connection_factory_lookup_type(family: GSocketFamily, type_: GSocketType, protocol_id: gint) -> GType;
    pub fn g_socket_connection_factory_register_type(g_type: GType, family: GSocketFamily, type_: GSocketType, protocol: gint);
    pub fn g_socket_connection_get_local_address(connection: *mut GSocketConnection) -> *mut GSocketAddress;
    pub fn g_socket_connection_get_remote_address(connection: *mut GSocketConnection) -> *mut GSocketAddress;
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;
    pub fn g_socket_control_message_deserialize(level: gint, type_: gint, size: gsize, data: gpointer) -> *mut GSocketControlMessage;
    pub fn g_socket_control_message_get_level(message: *mut GSocketControlMessage) -> gint;
    pub fn g_socket_control_message_get_msg_type(message: *mut GSocketControlMessage) -> gint;
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> gsize;
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);
    pub fn g_socket_create_source(socket: *mut GSocket, condition: glib::GIOCondition, cancellable: *mut GCancellable) -> *mut glib::GSource;
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_credentials(socket: *mut GSocket) -> *mut GCredentials;
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
    pub fn g_socket_get_fd(socket: *mut GSocket) -> gint;
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
    pub fn g_socket_get_local_address(socket: *mut GSocket) -> *mut GSocketAddress;
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
    pub fn g_socket_get_option(socket: *mut GSocket, level: gint, optname: gint, value: *mut gint) -> gboolean;
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
    pub fn g_socket_get_remote_address(socket: *mut GSocket) -> *mut GSocketAddress;
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_join_multicast_group(socket: *mut GSocket, group: *mut GInetAddress, source_specific: gboolean, iface: *const gchar) -> gboolean;
    pub fn g_socket_leave_multicast_group(socket: *mut GSocket, group: *mut GInetAddress, source_specific: gboolean, iface: *const gchar) -> gboolean;
    pub fn g_socket_listen(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_listener_accept(listener: *mut GSocketListener, source_object: *mut *mut gobject::GObject, cancellable: *mut GCancellable) -> *mut GSocketConnection;
    pub fn g_socket_listener_accept_async(listener: *mut GSocketListener, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_listener_accept_finish(listener: *mut GSocketListener, result: *mut GAsyncResult, source_object: *mut *mut gobject::GObject) -> *mut GSocketConnection;
    pub fn g_socket_listener_accept_socket(listener: *mut GSocketListener, source_object: *mut *mut gobject::GObject, cancellable: *mut GCancellable) -> *mut GSocket;
    pub fn g_socket_listener_accept_socket_async(listener: *mut GSocketListener, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_socket_listener_accept_socket_finish(listener: *mut GSocketListener, result: *mut GAsyncResult, source_object: *mut *mut gobject::GObject) -> *mut GSocket;
    pub fn g_socket_listener_add_address(listener: *mut GSocketListener, address: *mut GSocketAddress, type_: GSocketType, protocol: GSocketProtocol, source_object: *mut gobject::GObject, effective_address: *mut *mut GSocketAddress) -> gboolean;
    pub fn g_socket_listener_add_any_inet_port(listener: *mut GSocketListener, source_object: *mut gobject::GObject) -> u16;
    pub fn g_socket_listener_add_inet_port(listener: *mut GSocketListener, port: u16, source_object: *mut gobject::GObject) -> gboolean;
    pub fn g_socket_listener_add_socket(listener: *mut GSocketListener, socket: *mut GSocket, source_object: *mut gobject::GObject) -> gboolean;
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
    pub fn g_socket_listener_new() -> *mut GSocketListener;
    pub fn g_socket_listener_set_backlog(listener: *mut GSocketListener, listen_backlog: gint);
    pub fn g_socket_new(family: GSocketFamily, type_: GSocketType, protocol: GSocketProtocol) -> *mut GSocket;
    pub fn g_socket_new_from_fd(fd: gint) -> *mut GSocket;
    pub fn g_socket_receive(socket: *mut GSocket, buffer: *mut gchar, size: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_receive_from(socket: *mut GSocket, address: *mut *mut GSocketAddress, buffer: *mut gchar, size: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_receive_message(socket: *mut GSocket, address: *mut *mut GSocketAddress, vectors: *mut GInputVector, num_vectors: gint, messages: *mut *mut *mut GSocketControlMessage, num_messages: gint, flags: gint, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_receive_messages(socket: *mut GSocket, messages: *mut GInputMessage, num_messages: guint, flags: gint, cancellable: *mut GCancellable) -> gint;
    pub fn g_socket_receive_with_blocking(socket: *mut GSocket, buffer: *mut gchar, size: gsize, blocking: gboolean, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_send(socket: *mut GSocket, buffer: *mut gchar, size: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_send_message(socket: *mut GSocket, address: *mut GSocketAddress, vectors: *mut GOutputVector, num_vectors: gint, messages: *mut *mut GSocketControlMessage, num_messages: gint, flags: gint, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_send_messages(socket: *mut GSocket, messages: *mut GOutputMessage, num_messages: guint, flags: gint, cancellable: *mut GCancellable) -> gint;
    pub fn g_socket_send_to(socket: *mut GSocket, address: *mut GSocketAddress, buffer: *mut gchar, size: gsize, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_send_with_blocking(socket: *mut GSocket, buffer: *mut gchar, size: gsize, blocking: gboolean, cancellable: *mut GCancellable) -> gssize;
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
    pub fn g_socket_service_new() -> *mut GSocketService;
    pub fn g_socket_service_start(service: *mut GSocketService);
    pub fn g_socket_service_stop(service: *mut GSocketService);
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
    pub fn g_socket_set_option(socket: *mut GSocket, level: gint, optname: gint, value: gint) -> gboolean;
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
    pub fn g_socket_shutdown(socket: *mut GSocket, shutdown_read: gboolean, shutdown_write: gboolean) -> gboolean;
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
    pub fn g_srv_target_free(target: *mut GSrvTarget);
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> u16;
    pub fn g_srv_target_list_sort(targets: *mut glib::GList) -> *mut glib::GList;
    pub fn g_srv_target_new(hostname: *const gchar, port: u16, priority: u16, weight: u16) -> *mut GSrvTarget;
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
    pub fn g_subprocess_communicate(subprocess: *mut GSubprocess, stdin_buf: *mut glib::GBytes, cancellable: *mut GCancellable, stdout_buf: *mut *mut glib::GBytes, stderr_buf: *mut *mut glib::GBytes) -> gboolean;
    pub fn g_subprocess_communicate_async(subprocess: *mut GSubprocess, stdin_buf: *mut glib::GBytes, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_subprocess_communicate_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, stdout_buf: *mut *mut glib::GBytes, stderr_buf: *mut *mut glib::GBytes) -> gboolean;
    pub fn g_subprocess_communicate_utf8(subprocess: *mut GSubprocess, stdin_buf: *const gchar, cancellable: *mut GCancellable, stdout_buf: *mut *mut gchar, stderr_buf: *mut *mut gchar) -> gboolean;
    pub fn g_subprocess_communicate_utf8_async(subprocess: *mut GSubprocess, stdin_buf: *const gchar, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_subprocess_communicate_utf8_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult, stdout_buf: *mut *mut gchar, stderr_buf: *mut *mut gchar) -> gboolean;
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const gchar;
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_launcher_getenv(self_: *mut GSubprocessLauncher, variable: *const gchar) -> *const gchar;
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *const gchar);
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut gchar);
    pub fn g_subprocess_launcher_set_flags(self_: *mut GSubprocessLauncher, flags: GSubprocessFlags);
    pub fn g_subprocess_launcher_setenv(self_: *mut GSubprocessLauncher, variable: *const gchar, value: *const gchar, overwrite: gboolean);
    pub fn g_subprocess_launcher_spawn(self_: *mut GSubprocessLauncher, error: *mut *mut glib::GError, argv0: *const gchar, ...) -> *mut GSubprocess;
    pub fn g_subprocess_launcher_spawnv(self_: *mut GSubprocessLauncher, argv: *mut *mut gchar) -> *mut GSubprocess;
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const gchar);
    pub fn g_subprocess_new(flags: GSubprocessFlags, error: *mut *mut glib::GError, argv0: *const gchar, ...) -> *mut GSubprocess;
    pub fn g_subprocess_newv(argv: *mut *mut gchar, flags: GSubprocessFlags) -> *mut GSubprocess;
    pub fn g_subprocess_wait(subprocess: *mut GSubprocess, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_subprocess_wait_async(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_subprocess_wait_check(subprocess: *mut GSubprocess, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_subprocess_wait_check_async(subprocess: *mut GSubprocess, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_subprocess_wait_check_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult) -> gboolean;
    pub fn g_subprocess_wait_finish(subprocess: *mut GSubprocess, result: *mut GAsyncResult) -> gboolean;
    pub fn g_task_attach_source(task: *mut GTask, source: *mut glib::GSource, callback: glib::GSourceFunc);
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
    pub fn g_task_get_context(task: *mut GTask) -> *mut glib::GMainContext;
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer) -> gboolean;
    pub fn g_task_new(source_object: gpointer, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, callback_data: gpointer) -> *mut GTask;
    pub fn g_task_propagate_boolean(task: *mut GTask) -> gboolean;
    pub fn g_task_propagate_int(task: *mut GTask) -> gssize;
    pub fn g_task_propagate_pointer(task: *mut GTask) -> gpointer;
    pub fn g_task_report_error(source_object: gpointer, callback: Option<GAsyncReadyCallback>, callback_data: gpointer, source_tag: gpointer, error: *mut glib::GError);
    pub fn g_task_report_new_error(source_object: gpointer, callback: Option<GAsyncReadyCallback>, callback_data: gpointer, source_tag: gpointer, domain: glib::GQuark, code: gint, format: *const gchar, ...);
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
    pub fn g_task_return_error(task: *mut GTask, error: *mut glib::GError);
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
    pub fn g_task_return_new_error(task: *mut GTask, domain: glib::GQuark, code: gint, format: *const gchar, ...);
    pub fn g_task_return_pointer(task: *mut GTask, result: gpointer, result_destroy: Option<glib::GDestroyNotify>);
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
    pub fn g_task_set_task_data(task: *mut GTask, task_data: gpointer, task_data_destroy: Option<glib::GDestroyNotify>);
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
    pub fn g_tcp_connection_set_graceful_disconnect(connection: *mut GTcpConnection, graceful_disconnect: gboolean);
    pub fn g_tcp_wrapper_connection_get_base_io_stream(conn: *mut GTcpWrapperConnection) -> *mut GIOStream;
    pub fn g_tcp_wrapper_connection_new(base_io_stream: *mut GIOStream, socket: *mut GSocket) -> *mut GSocketConnection;
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const gchar);
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const gchar;
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
    pub fn g_test_dbus_unset();
    pub fn g_test_dbus_up(self_: *mut GTestDBus);
    pub fn g_themed_icon_append_name(icon: *mut GThemedIcon, iconname: *const gchar);
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const gchar;
    pub fn g_themed_icon_new(iconname: *const gchar) -> *mut GIcon;
    pub fn g_themed_icon_new_from_names(iconnames: *mut *mut gchar, len: gint) -> *mut GIcon;
    pub fn g_themed_icon_new_with_default_fallbacks(iconname: *const gchar) -> *mut GIcon;
    pub fn g_themed_icon_prepend_name(icon: *mut GThemedIcon, iconname: *const gchar);
    pub fn g_threaded_socket_service_new(max_threads: gint) -> *mut GSocketService;
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_is_same(cert_one: *mut GTlsCertificate, cert_two: *mut GTlsCertificate) -> gboolean;
    pub fn g_tls_certificate_list_new_from_file(file: *const gchar) -> *mut glib::GList;
    pub fn g_tls_certificate_new_from_file(file: *const gchar) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_files(cert_file: *const gchar, key_file: *const gchar) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_pem(data: *const gchar, length: gssize) -> *mut GTlsCertificate;
    pub fn g_tls_certificate_verify(cert: *mut GTlsCertificate, identity: *mut GSocketConnectable, trusted_ca: *mut GTlsCertificate) -> GTlsCertificateFlags;
    pub fn g_tls_client_connection_copy_session_state(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection);
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut glib::GList;
    pub fn g_tls_client_connection_get_server_identity(conn: *mut GTlsClientConnection) -> *mut GSocketConnectable;
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
    pub fn g_tls_client_connection_get_validation_flags(conn: *mut GTlsClientConnection) -> GTlsCertificateFlags;
    pub fn g_tls_client_connection_new(base_io_stream: *mut GIOStream, server_identity: *mut GSocketConnectable) -> *mut GIOStream;
    pub fn g_tls_client_connection_set_server_identity(conn: *mut GTlsClientConnection, identity: *mut GSocketConnectable);
    pub fn g_tls_client_connection_set_use_ssl3(conn: *mut GTlsClientConnection, use_ssl3: gboolean);
    pub fn g_tls_client_connection_set_validation_flags(conn: *mut GTlsClientConnection, flags: GTlsCertificateFlags);
    pub fn g_tls_connection_emit_accept_certificate(conn: *mut GTlsConnection, peer_cert: *mut GTlsCertificate, errors: GTlsCertificateFlags) -> gboolean;
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
    pub fn g_tls_connection_get_peer_certificate_errors(conn: *mut GTlsConnection) -> GTlsCertificateFlags;
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
    pub fn g_tls_connection_handshake(conn: *mut GTlsConnection, cancellable: *mut GCancellable) -> gboolean;
    pub fn g_tls_connection_handshake_async(conn: *mut GTlsConnection, io_priority: gint, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_connection_handshake_finish(conn: *mut GTlsConnection, result: *mut GAsyncResult) -> gboolean;
    pub fn g_tls_connection_set_certificate(conn: *mut GTlsConnection, certificate: *mut GTlsCertificate);
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
    pub fn g_tls_connection_set_interaction(conn: *mut GTlsConnection, interaction: *mut GTlsInteraction);
    pub fn g_tls_connection_set_rehandshake_mode(conn: *mut GTlsConnection, mode: GTlsRehandshakeMode);
    pub fn g_tls_connection_set_require_close_notify(conn: *mut GTlsConnection, require_close_notify: gboolean);
    pub fn g_tls_connection_set_use_system_certdb(conn: *mut GTlsConnection, use_system_certdb: gboolean);
    pub fn g_tls_database_create_certificate_handle(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate) -> *mut gchar;
    pub fn g_tls_database_lookup_certificate_for_handle(self_: *mut GTlsDatabase, handle: *const gchar, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_for_handle_async(self_: *mut GTlsDatabase, handle: *const gchar, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_database_lookup_certificate_for_handle_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer_async(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_database_lookup_certificate_issuer_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult) -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificates_issued_by(self_: *mut GTlsDatabase, issuer_raw_dn: *mut glib::GByteArray, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable) -> *mut glib::GList;
    pub fn g_tls_database_lookup_certificates_issued_by_async(self_: *mut GTlsDatabase, issuer_raw_dn: *mut glib::GByteArray, interaction: *mut GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_database_lookup_certificates_issued_by_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult) -> *mut glib::GList;
    pub fn g_tls_database_verify_chain(self_: *mut GTlsDatabase, chain: *mut GTlsCertificate, purpose: *const gchar, identity: *mut GSocketConnectable, interaction: *mut GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: *mut GCancellable) -> GTlsCertificateFlags;
    pub fn g_tls_database_verify_chain_async(self_: *mut GTlsDatabase, chain: *mut GTlsCertificate, purpose: *const gchar, identity: *mut GSocketConnectable, interaction: *mut GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_database_verify_chain_finish(self_: *mut GTlsDatabase, result: *mut GAsyncResult) -> GTlsCertificateFlags;
    pub fn g_tls_error_quark() -> glib::GQuark;
    pub fn g_tls_file_database_new(anchors: *const gchar) -> *mut GTlsDatabase;
    pub fn g_tls_interaction_ask_password(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable) -> GTlsInteractionResult;
    pub fn g_tls_interaction_ask_password_async(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_interaction_ask_password_finish(interaction: *mut GTlsInteraction, result: *mut GAsyncResult) -> GTlsInteractionResult;
    pub fn g_tls_interaction_invoke_ask_password(interaction: *mut GTlsInteraction, password: *mut GTlsPassword, cancellable: *mut GCancellable) -> GTlsInteractionResult;
    pub fn g_tls_interaction_invoke_request_certificate(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable) -> GTlsInteractionResult;
    pub fn g_tls_interaction_request_certificate(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable) -> GTlsInteractionResult;
    pub fn g_tls_interaction_request_certificate_async(interaction: *mut GTlsInteraction, connection: *mut GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_tls_interaction_request_certificate_finish(interaction: *mut GTlsInteraction, result: *mut GAsyncResult) -> GTlsInteractionResult;
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const gchar;
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
    pub fn g_tls_password_get_value(password: *mut GTlsPassword, length: gsize) -> u8;
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const gchar;
    pub fn g_tls_password_new(flags: GTlsPasswordFlags, description: *const gchar) -> *mut GTlsPassword;
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const gchar);
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
    pub fn g_tls_password_set_value(password: *mut GTlsPassword, value: u8, length: gssize);
    pub fn g_tls_password_set_value_full(password: *mut GTlsPassword, value: u8, length: gssize, destroy: Option<glib::GDestroyNotify>);
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const gchar);
    pub fn g_tls_server_connection_new(base_io_stream: *mut GIOStream, certificate: *mut GTlsCertificate) -> *mut GIOStream;
    pub fn g_vfs_get_default() -> *mut GVfs;
    pub fn g_vfs_get_file_for_path(vfs: *mut GVfs, path: *const gchar) -> *mut GFile;
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const gchar) -> *mut GFile;
    pub fn g_vfs_get_local() -> *mut GVfs;
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const gchar;
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
    pub fn g_vfs_parse_name(vfs: *mut GVfs, parse_name: *const gchar) -> *mut GFile;
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_eject(volume: *mut GVolume, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_volume_eject_finish(volume: *mut GVolume, result: *mut GAsyncResult) -> gboolean;
    pub fn g_volume_eject_with_operation(volume: *mut GVolume, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_volume_eject_with_operation_finish(volume: *mut GVolume, result: *mut GAsyncResult) -> gboolean;
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume) -> *mut *mut gchar;
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_identifier(volume: *mut GVolume, kind: *const gchar) -> *mut gchar;
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut gchar;
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut gchar;
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;
    pub fn g_volume_monitor_get_mount_for_uuid(volume_monitor: *mut GVolumeMonitor, uuid: *const gchar) -> *mut GMount;
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;
    pub fn g_volume_monitor_get_volume_for_uuid(volume_monitor: *mut GVolumeMonitor, uuid: *const gchar) -> *mut GVolume;
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut glib::GList;
    pub fn g_volume_mount(volume: *mut GVolume, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
    pub fn g_volume_mount_finish(volume: *mut GVolume, result: *mut GAsyncResult) -> gboolean;
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
    pub fn g_zlib_compressor_new(format: GZlibCompressorFormat, level: gint) -> *mut GZlibCompressor;
    pub fn g_zlib_compressor_set_file_info(compressor: *mut GZlibCompressor, file_info: *mut GFileInfo);
    pub fn g_zlib_decompressor_get_file_info(decompressor: *mut GZlibDecompressor) -> *mut GFileInfo;
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
}

#[cfg(unix)]
pub mod unix {
    use gtypes::*;
    use super::*;
    use glib;
    use gobject;
    use libc;

    pub enum GDesktopAppInfo { }

    #[repr(C)]
    pub struct GDesktopAppInfoClass {
        pub parent_class: gobject::GObjectClass,
    }

    pub enum GDesktopAppInfoLookup { }

    #[repr(C)]
    pub struct GDesktopAppInfoLookupIface {
        pub g_iface: gobject::GTypeInterface,
        pub get_default_for_uri_scheme: Option<extern "C" fn (*mut GDesktopAppInfoLookup, *const gchar) -> *mut GAppInfo>,
    }

    pub enum GFileDescriptorBased { }

    #[repr(C)]
    pub struct GFileDescriptorBasedIface {
        pub g_iface: gobject::GTypeInterface,
        pub get_fd: Option<extern "C" fn (*mut GFileDescriptorBased) -> gint>,
    }

    #[repr(C)]
    pub struct GUnixConnection {
        pub parent_instance: GSocketConnection,
        pub priv_: *mut GUnixConnectionPrivate,
    }

    #[repr(C)]
    pub struct GUnixConnectionClass {
        pub parent_class: GSocketConnectionClass,
    }

    #[repr(C)]
    pub struct GUnixConnectionPrivate(gpointer);

    #[repr(C)]
    pub struct GUnixCredentialsMessage {
        pub parent_instance: GSocketControlMessage,
        pub priv_: *mut GUnixCredentialsMessagePrivate,
    }

    #[repr(C)]
    pub struct GUnixCredentialsMessageClass {
        pub parent_class: GSocketControlMessageClass,
        pub _g_reserved1: Option<extern "C" fn ()>,
        pub _g_reserved2: Option<extern "C" fn ()>,
    }

    #[repr(C)]
    pub struct GUnixCredentialsMessagePrivate(gpointer);

    #[repr(C)]
    pub struct GUnixFDList {
        pub parent_instance: gobject::GObject,
        pub priv_: *mut GUnixFDListPrivate,
    }

    #[repr(C)]
    pub struct GUnixFDListClass {
        pub parent_class: gobject::GObjectClass,
        pub _g_reserved1: Option<extern "C" fn ()>,
        pub _g_reserved2: Option<extern "C" fn ()>,
        pub _g_reserved3: Option<extern "C" fn ()>,
        pub _g_reserved4: Option<extern "C" fn ()>,
        pub _g_reserved5: Option<extern "C" fn ()>,
    }

    #[repr(C)]
    pub struct GUnixFDListPrivate(gpointer);

    #[repr(C)]
    pub struct GUnixFDMessage {
        pub parent_instance: GSocketControlMessage,
        pub priv_: *mut GUnixFDMessagePrivate,
    }

    #[repr(C)]
    pub struct GUnixFDMessageClass {
        pub parent_class: GSocketControlMessageClass,
        pub _g_reserved1: Option<extern "C" fn ()>,
        pub _g_reserved2: Option<extern "C" fn ()>,
    }

    #[repr(C)]
    pub struct GUnixFDMessagePrivate(gpointer);

    #[repr(C)]
    pub struct GUnixInputStream {
        pub parent_instance: GInputStream,
        priv_: *mut GUnixInputStreamPrivate,
    }

    #[repr(C)]
    pub struct GUnixInputStreamClass {
        pub parent_class: GInputStreamClass,
        pub _g_reserved1: Option<extern "C" fn ()>,
        pub _g_reserved2: Option<extern "C" fn ()>,
        pub _g_reserved3: Option<extern "C" fn ()>,
        pub _g_reserved4: Option<extern "C" fn ()>,
        pub _g_reserved5: Option<extern "C" fn ()>,
    }

    #[repr(C)]
    pub struct GUnixInputStreamPrivate(gpointer);

    #[repr(C)]
    pub struct GUnixMountEntry(gpointer);

    pub enum GUnixMountMonitor { }

    #[repr(C)]
    pub struct GUnixMountMonitorClass(gpointer);

    #[repr(C)]
    pub struct GUnixMountPoint(gpointer);

    #[repr(C)]
    pub struct GUnixOutputStream {
        pub parent_instance: GOutputStream,
        priv_: *mut GUnixOutputStreamPrivate,
    }

    #[repr(C)]
    pub struct GUnixOutputStreamClass {
        pub parent_class: GOutputStreamClass,
        pub _g_reserved1: Option<extern "C" fn ()>,
        pub _g_reserved2: Option<extern "C" fn ()>,
        pub _g_reserved3: Option<extern "C" fn ()>,
        pub _g_reserved4: Option<extern "C" fn ()>,
        pub _g_reserved5: Option<extern "C" fn ()>,
    }

    #[repr(C)]
    pub struct GUnixOutputStreamPrivate(gpointer);

    #[repr(C)]
    pub struct GUnixSocketAddress {
        pub parent_instance: GSocketAddress,
        priv_: *mut GUnixSocketAddressPrivate,
    }

    #[repr(C)]
    pub struct GUnixSocketAddressClass {
        pub parent_class: GSocketAddressClass,
    }

    #[repr(C)]
    pub struct GUnixSocketAddressPrivate(gpointer);

    #[repr(C)]
    pub enum GUnixSocketAddressType {
        Invalid = 0,
        Anonymous = 1,
        Path = 2,
        Abstract = 3,
        AbstractPadded = 4,
    }
    pub const G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = GUnixSocketAddressType::Invalid;
    pub const G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = GUnixSocketAddressType::Anonymous;
    pub const G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = GUnixSocketAddressType::Path;
    pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = GUnixSocketAddressType::Abstract;
    pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = GUnixSocketAddressType::AbstractPadded;

    // GType functions
    extern {
        pub fn g_desktop_app_info_get_type() -> GType;
        pub fn g_desktop_app_info_lookup_get_type() -> GType;
        pub fn g_file_descriptor_based_get_type() -> GType;
        pub fn g_unix_connection_get_type() -> GType;
        pub fn g_unix_credentials_message_get_type() -> GType;
        pub fn g_unix_fd_list_get_type() -> GType;
        pub fn g_unix_fd_message_get_type() -> GType;
        pub fn g_unix_input_stream_get_type() -> GType;
        pub fn g_unix_mount_monitor_get_type() -> GType;
        pub fn g_unix_output_stream_get_type() -> GType;
        pub fn g_unix_socket_address_get_type() -> GType;
        pub fn g_unix_socket_address_type_get_type() -> GType;
    }

    extern {
        pub fn g_credentials_get_unix_pid(credentials: *mut GCredentials) -> libc::pid_t;
        pub fn g_credentials_get_unix_user(credentials: *mut GCredentials) -> libc::uid_t;
        pub fn g_desktop_app_info_get_action_name(info: *mut GDesktopAppInfo, action_name: *const gchar) -> *mut gchar;
        pub fn g_desktop_app_info_get_boolean(info: *mut GDesktopAppInfo, key: *const gchar) -> gboolean;
        pub fn g_desktop_app_info_get_categories(info: *mut GDesktopAppInfo) -> *const gchar;
        pub fn g_desktop_app_info_get_filename(info: *mut GDesktopAppInfo) -> *const gchar;
        pub fn g_desktop_app_info_get_generic_name(info: *mut GDesktopAppInfo) -> *const gchar;
        pub fn g_desktop_app_info_get_implementations(interface: *const gchar) -> *mut glib::GList;
        pub fn g_desktop_app_info_get_is_hidden(info: *mut GDesktopAppInfo) -> gboolean;
        pub fn g_desktop_app_info_get_keywords(info: *mut GDesktopAppInfo) -> *const *const gchar;
        pub fn g_desktop_app_info_get_nodisplay(info: *mut GDesktopAppInfo) -> gboolean;
        pub fn g_desktop_app_info_get_show_in(info: *mut GDesktopAppInfo, desktop_env: *const gchar) -> gboolean;
        pub fn g_desktop_app_info_get_startup_wm_class(info: *mut GDesktopAppInfo) -> *const gchar;
        pub fn g_desktop_app_info_get_string(info: *mut GDesktopAppInfo, key: *const gchar) -> *mut gchar;
        pub fn g_desktop_app_info_has_key(info: *mut GDesktopAppInfo, key: *const gchar) -> gboolean;
        pub fn g_desktop_app_info_launch_action(info: *mut GDesktopAppInfo, action_name: *const gchar, launch_context: *mut GAppLaunchContext);
        pub fn g_desktop_app_info_launch_uris_as_manager(appinfo: *mut GDesktopAppInfo, uris: *mut glib::GList, launch_context: *mut GAppLaunchContext, spawn_flags: glib::GSpawnFlags, user_setup: Option<glib::GSpawnChildSetupFunc>, user_setup_data: gpointer, pid_callback: Option<GDesktopAppLaunchCallback>, pid_callback_data: gpointer) -> gboolean;
        pub fn g_desktop_app_info_list_actions(info: *mut GDesktopAppInfo) -> *mut *mut gchar;
        pub fn g_desktop_app_info_lookup_get_default_for_uri_scheme(lookup: *mut GDesktopAppInfoLookup, uri_scheme: *const gchar) -> *mut GAppInfo;
        pub fn g_desktop_app_info_new(desktop_id: *const gchar) -> *mut GDesktopAppInfo;
        pub fn g_desktop_app_info_new_from_filename(filename: *const gchar) -> *mut GDesktopAppInfo;
        pub fn g_desktop_app_info_new_from_keyfile(key_file: *mut glib::GKeyFile) -> *mut GDesktopAppInfo;
        pub fn g_desktop_app_info_search(search_string: *const gchar) -> *mut *mut *mut gchar;
        pub fn g_desktop_app_info_set_desktop_env(desktop_env: *const gchar);
        pub fn g_file_descriptor_based_get_fd(fd_based: *mut GFileDescriptorBased) -> gint;
        pub fn g_subprocess_launcher_set_child_setup(self_: *mut GSubprocessLauncher, child_setup: glib::GSpawnChildSetupFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
        pub fn g_subprocess_launcher_set_stderr_file_path(self_: *mut GSubprocessLauncher, path: *const gchar);
        pub fn g_subprocess_launcher_set_stdin_file_path(self_: *mut GSubprocessLauncher, path: *const gchar);
        pub fn g_subprocess_launcher_set_stdout_file_path(self_: *mut GSubprocessLauncher, path: *const gchar);
        pub fn g_subprocess_launcher_take_fd(self_: *mut GSubprocessLauncher, source_fd: gint, target_fd: gint);
        pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: gint);
        pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: gint);
        pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: gint);
        pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: gint);
        pub fn g_unix_connection_receive_credentials(connection: *mut GUnixConnection, cancellable: *mut GCancellable) -> *mut GCredentials;
        pub fn g_unix_connection_receive_credentials_async(connection: *mut GUnixConnection, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
        pub fn g_unix_connection_receive_credentials_finish(connection: *mut GUnixConnection, result: *mut GAsyncResult) -> *mut GCredentials;
        pub fn g_unix_connection_receive_fd(connection: *mut GUnixConnection, cancellable: *mut GCancellable) -> gint;
        pub fn g_unix_connection_send_credentials(connection: *mut GUnixConnection, cancellable: *mut GCancellable) -> gboolean;
        pub fn g_unix_connection_send_credentials_async(connection: *mut GUnixConnection, cancellable: *mut GCancellable, callback: Option<GAsyncReadyCallback>, user_data: gpointer);
        pub fn g_unix_connection_send_credentials_finish(connection: *mut GUnixConnection, result: *mut GAsyncResult) -> gboolean;
        pub fn g_unix_connection_send_fd(connection: *mut GUnixConnection, fd: gint, cancellable: *mut GCancellable) -> gboolean;
        pub fn g_unix_credentials_message_get_credentials(message: *mut GUnixCredentialsMessage) -> *mut GCredentials;
        pub fn g_unix_credentials_message_is_supported() -> gboolean;
        pub fn g_unix_credentials_message_new() -> *mut GSocketControlMessage;
        pub fn g_unix_credentials_message_new_with_credentials(credentials: *mut GCredentials) -> *mut GSocketControlMessage;
        pub fn g_unix_fd_list_append(list: *mut GUnixFDList, fd: gint) -> gint;
        pub fn g_unix_fd_list_get(list: *mut GUnixFDList, index_: gint) -> gint;
        pub fn g_unix_fd_list_get_length(list: *mut GUnixFDList) -> gint;
        pub fn g_unix_fd_list_new() -> *mut GUnixFDList;
        pub fn g_unix_fd_list_new_from_array(fds: *mut gint, n_fds: gint) -> *mut GUnixFDList;
        pub fn g_unix_fd_list_peek_fds(list: *mut GUnixFDList, length: *mut gint) -> *mut gint;
        pub fn g_unix_fd_list_steal_fds(list: *mut GUnixFDList, length: *mut gint) -> *mut gint;
        pub fn g_unix_fd_message_append_fd(message: *mut GUnixFDMessage, fd: gint) -> gboolean;
        pub fn g_unix_fd_message_get_fd_list(message: *mut GUnixFDMessage) -> *mut GUnixFDList;
        pub fn g_unix_fd_message_new() -> *mut GSocketControlMessage;
        pub fn g_unix_fd_message_new_with_fd_list(fd_list: *mut GUnixFDList) -> *mut GSocketControlMessage;
        pub fn g_unix_fd_message_steal_fds(message: *mut GUnixFDMessage, length: *mut gint) -> *mut gint;
        pub fn g_unix_input_stream_get_close_fd(stream: *mut GUnixInputStream) -> gboolean;
        pub fn g_unix_input_stream_get_fd(stream: *mut GUnixInputStream) -> gint;
        pub fn g_unix_input_stream_new(fd: gint, close_fd: gboolean) -> *mut GInputStream;
        pub fn g_unix_input_stream_set_close_fd(stream: *mut GUnixInputStream, close_fd: gboolean);
        pub fn g_unix_is_mount_path_system_internal(mount_path: *const gchar) -> gboolean;
        pub fn g_unix_mount_at(mount_path: *const gchar, time_read: *mut u64) -> *mut GUnixMountEntry;
        pub fn g_unix_mount_compare(mount1: *mut GUnixMountEntry, mount2: *mut GUnixMountEntry) -> gint;
        pub fn g_unix_mount_free(mount_entry: *mut GUnixMountEntry);
        pub fn g_unix_mount_get_device_path(mount_entry: *mut GUnixMountEntry) -> *const gchar;
        pub fn g_unix_mount_get_fs_type(mount_entry: *mut GUnixMountEntry) -> *const gchar;
        pub fn g_unix_mount_get_mount_path(mount_entry: *mut GUnixMountEntry) -> *const gchar;
        pub fn g_unix_mount_guess_can_eject(mount_entry: *mut GUnixMountEntry) -> gboolean;
        pub fn g_unix_mount_guess_icon(mount_entry: *mut GUnixMountEntry) -> *mut GIcon;
        pub fn g_unix_mount_guess_name(mount_entry: *mut GUnixMountEntry) -> *mut gchar;
        pub fn g_unix_mount_guess_should_display(mount_entry: *mut GUnixMountEntry) -> gboolean;
        pub fn g_unix_mount_guess_symbolic_icon(mount_entry: *mut GUnixMountEntry) -> *mut GIcon;
        pub fn g_unix_mount_is_readonly(mount_entry: *mut GUnixMountEntry) -> gboolean;
        pub fn g_unix_mount_is_system_internal(mount_entry: *mut GUnixMountEntry) -> gboolean;
        pub fn g_unix_mount_monitor_get() -> *mut GUnixMountMonitor;
        pub fn g_unix_mount_monitor_new() -> *mut GUnixMountMonitor;
        pub fn g_unix_mount_monitor_set_rate_limit(mount_monitor: *mut GUnixMountMonitor, limit_msec: gint);
        pub fn g_unix_mount_point_compare(mount1: *mut GUnixMountPoint, mount2: *mut GUnixMountPoint) -> gint;
        pub fn g_unix_mount_point_free(mount_point: *mut GUnixMountPoint);
        pub fn g_unix_mount_point_get_device_path(mount_point: *mut GUnixMountPoint) -> *const gchar;
        pub fn g_unix_mount_point_get_fs_type(mount_point: *mut GUnixMountPoint) -> *const gchar;
        pub fn g_unix_mount_point_get_mount_path(mount_point: *mut GUnixMountPoint) -> *const gchar;
        pub fn g_unix_mount_point_get_options(mount_point: *mut GUnixMountPoint) -> *const gchar;
        pub fn g_unix_mount_point_guess_can_eject(mount_point: *mut GUnixMountPoint) -> gboolean;
        pub fn g_unix_mount_point_guess_icon(mount_point: *mut GUnixMountPoint) -> *mut GIcon;
        pub fn g_unix_mount_point_guess_name(mount_point: *mut GUnixMountPoint) -> *mut gchar;
        pub fn g_unix_mount_point_guess_symbolic_icon(mount_point: *mut GUnixMountPoint) -> *mut GIcon;
        pub fn g_unix_mount_point_is_loopback(mount_point: *mut GUnixMountPoint) -> gboolean;
        pub fn g_unix_mount_point_is_readonly(mount_point: *mut GUnixMountPoint) -> gboolean;
        pub fn g_unix_mount_point_is_user_mountable(mount_point: *mut GUnixMountPoint) -> gboolean;
        pub fn g_unix_mount_points_changed_since(time: u64) -> gboolean;
        pub fn g_unix_mount_points_get(time_read: *mut u64) -> *mut glib::GList;
        pub fn g_unix_mounts_changed_since(time: u64) -> gboolean;
        pub fn g_unix_mounts_get(time_read: *mut u64) -> *mut glib::GList;
        pub fn g_unix_output_stream_get_close_fd(stream: *mut GUnixOutputStream) -> gboolean;
        pub fn g_unix_output_stream_get_fd(stream: *mut GUnixOutputStream) -> gint;
        pub fn g_unix_output_stream_new(fd: gint, close_fd: gboolean) -> *mut GOutputStream;
        pub fn g_unix_output_stream_set_close_fd(stream: *mut GUnixOutputStream, close_fd: gboolean);
        pub fn g_unix_socket_address_abstract_names_supported() -> gboolean;
        pub fn g_unix_socket_address_get_address_type(address: *mut GUnixSocketAddress) -> GUnixSocketAddressType;
        pub fn g_unix_socket_address_get_is_abstract(address: *mut GUnixSocketAddress) -> gboolean;
        pub fn g_unix_socket_address_get_path(address: *mut GUnixSocketAddress) -> *const gchar;
        pub fn g_unix_socket_address_get_path_len(address: *mut GUnixSocketAddress) -> gsize;
        pub fn g_unix_socket_address_new(path: *const gchar) -> *mut GSocketAddress;
        pub fn g_unix_socket_address_new_abstract(path: *mut gchar, path_len: gint) -> *mut GSocketAddress;
        pub fn g_unix_socket_address_new_with_type(path: *mut gchar, path_len: gint, type_: GUnixSocketAddressType) -> *mut GSocketAddress;
    }
}

#[cfg(unix)]
pub use unix::*;
